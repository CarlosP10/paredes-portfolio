"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jarallax";
exports.ids = ["vendor-chunks/jarallax"];
exports.modules = {

/***/ "(ssr)/./node_modules/jarallax/dist/jarallax.cjs":
/*!*************************************************!*\
  !*** ./node_modules/jarallax/dist/jarallax.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * Jarallax v2.2.0 (https://github.com/nk-o/jarallax)\n * Copyright 2024 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/jarallax/blob/master/LICENSE)\n */\n\n\nvar defaults$1 = {\n  // Base parallax options.\n  type: 'scroll',\n  speed: 0.5,\n  containerClass: 'jarallax-container',\n  imgSrc: null,\n  imgElement: '.jarallax-img',\n  imgSize: 'cover',\n  imgPosition: '50% 50%',\n  imgRepeat: 'no-repeat',\n  keepImg: false,\n  elementInViewport: null,\n  zIndex: -100,\n  disableParallax: false,\n  // Callbacks.\n  onScroll: null,\n  onInit: null,\n  onDestroy: null,\n  onCoverImage: null,\n  // Video options.\n  videoClass: 'jarallax-video',\n  videoSrc: null,\n  videoStartTime: 0,\n  videoEndTime: 0,\n  videoVolume: 0,\n  videoLoop: true,\n  videoPlayOnlyVisible: true,\n  videoLazyLoading: true,\n  disableVideo: false,\n  // Video callbacks.\n  onVideoInsert: null,\n  onVideoWorkerInit: null\n};\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win$1;\nif (typeof window !== 'undefined') {\n  win$1 = window;\n} else if (typeof global !== 'undefined') {\n  win$1 = global;\n} else if (typeof self !== 'undefined') {\n  win$1 = self;\n} else {\n  win$1 = {};\n}\nvar global$2 = win$1;\n\n/**\n * Add styles to element.\n *\n * @param {Element} el - element.\n * @param {String|Object} styles - styles list.\n *\n * @returns {Element}\n */\nfunction css(el, styles) {\n  if (typeof styles === 'string') {\n    return global$2.getComputedStyle(el).getPropertyValue(styles);\n  }\n  Object.keys(styles).forEach(key => {\n    el.style[key] = styles[key];\n  });\n  return el;\n}\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend$1(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\n\n/**\n * Get all parents of the element.\n *\n * @param {Element} elem - DOM element.\n *\n * @returns {Array}\n */\nfunction getParents(elem) {\n  const parents = [];\n  while (elem.parentElement !== null) {\n    elem = elem.parentElement;\n    if (elem.nodeType === 1) {\n      parents.push(elem);\n    }\n  }\n  return parents;\n}\n\n/**\n * Document ready callback.\n * @param {Function} callback - callback will be fired once Document ready.\n */\nfunction ready(callback) {\n  if (document.readyState === 'complete' || document.readyState === 'interactive') {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true\n    });\n  }\n}\n\nconst {\n  navigator: navigator$1\n} = global$2;\nconst mobileAgent = /*#__PURE__*/ /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator$1.userAgent);\nfunction isMobile() {\n  return mobileAgent;\n}\n\nlet wndW;\nlet wndH;\nlet $deviceHelper;\n\n/**\n * The most popular mobile browsers changes height after page scroll and this generates image jumping.\n * We can fix it using this workaround with vh units.\n */\nfunction getDeviceHeight() {\n  if (!$deviceHelper && document.body) {\n    $deviceHelper = document.createElement('div');\n    $deviceHelper.style.cssText = 'position: fixed; top: -9999px; left: 0; height: 100vh; width: 0;';\n    document.body.appendChild($deviceHelper);\n  }\n  return ($deviceHelper ? $deviceHelper.clientHeight : 0) || global$2.innerHeight || document.documentElement.clientHeight;\n}\nfunction updateWindowHeight() {\n  wndW = global$2.innerWidth || document.documentElement.clientWidth;\n  if (isMobile()) {\n    wndH = getDeviceHeight();\n  } else {\n    wndH = global$2.innerHeight || document.documentElement.clientHeight;\n  }\n}\nupdateWindowHeight();\nglobal$2.addEventListener('resize', updateWindowHeight);\nglobal$2.addEventListener('orientationchange', updateWindowHeight);\nglobal$2.addEventListener('load', updateWindowHeight);\nready(() => {\n  updateWindowHeight();\n});\nfunction getWindowSize() {\n  return {\n    width: wndW,\n    height: wndH\n  };\n}\n\n// List with all jarallax instances\n// need to render all in one scroll/resize event.\nconst jarallaxList = [];\nfunction updateParallax() {\n  if (!jarallaxList.length) {\n    return;\n  }\n  const {\n    width: wndW,\n    height: wndH\n  } = getWindowSize();\n  jarallaxList.forEach((data, k) => {\n    const {\n      instance,\n      oldData\n    } = data;\n    if (!instance.isVisible()) {\n      return;\n    }\n    const clientRect = instance.$item.getBoundingClientRect();\n    const newData = {\n      width: clientRect.width,\n      height: clientRect.height,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      wndW,\n      wndH\n    };\n    const isResized = !oldData || oldData.wndW !== newData.wndW || oldData.wndH !== newData.wndH || oldData.width !== newData.width || oldData.height !== newData.height;\n    const isScrolled = isResized || !oldData || oldData.top !== newData.top || oldData.bottom !== newData.bottom;\n    jarallaxList[k].oldData = newData;\n    if (isResized) {\n      instance.onResize();\n    }\n    if (isScrolled) {\n      instance.onScroll();\n    }\n  });\n  global$2.requestAnimationFrame(updateParallax);\n}\nconst visibilityObserver = /*#__PURE__*/new global$2.IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    entry.target.jarallax.isElementInViewport = entry.isIntersecting;\n  });\n}, {\n  // We have to start parallax calculation before the block is in view\n  // to prevent possible parallax jumping.\n  rootMargin: '50px'\n});\nfunction addObserver(instance) {\n  jarallaxList.push({\n    instance\n  });\n  if (jarallaxList.length === 1) {\n    global$2.requestAnimationFrame(updateParallax);\n  }\n  visibilityObserver.observe(instance.options.elementInViewport || instance.$item);\n}\nfunction removeObserver(instance) {\n  jarallaxList.forEach((data, key) => {\n    if (data.instance.instanceID === instance.instanceID) {\n      jarallaxList.splice(key, 1);\n    }\n  });\n  visibilityObserver.unobserve(instance.options.elementInViewport || instance.$item);\n}\n\n/* eslint-disable class-methods-use-this */\nconst {\n  navigator\n} = global$2;\nlet instanceID = 0;\n\n// Jarallax class\nclass Jarallax {\n  constructor(item, userOptions) {\n    const self = this;\n    self.instanceID = instanceID;\n    instanceID += 1;\n    self.$item = item;\n    self.defaults = {\n      ...defaults$1\n    };\n\n    // prepare data-options\n    const dataOptions = self.$item.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach(key => {\n      const lowerCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (lowerCaseOption && typeof self.defaults[lowerCaseOption] !== 'undefined') {\n        pureDataOptions[lowerCaseOption] = dataOptions[key];\n      }\n    });\n    self.options = self.extend({}, self.defaults, pureDataOptions, userOptions);\n    self.pureOptions = self.extend({}, self.options);\n\n    // prepare 'true' and 'false' strings to boolean\n    Object.keys(self.options).forEach(key => {\n      if (self.options[key] === 'true') {\n        self.options[key] = true;\n      } else if (self.options[key] === 'false') {\n        self.options[key] = false;\n      }\n    });\n\n    // fix speed option [-1.0, 2.0]\n    self.options.speed = Math.min(2, Math.max(-1, parseFloat(self.options.speed)));\n\n    // prepare disableParallax callback\n    if (typeof self.options.disableParallax === 'string') {\n      self.options.disableParallax = new RegExp(self.options.disableParallax);\n    }\n    if (self.options.disableParallax instanceof RegExp) {\n      const disableParallaxRegexp = self.options.disableParallax;\n      self.options.disableParallax = () => disableParallaxRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableParallax !== 'function') {\n      self.options.disableParallax = () => false;\n    }\n\n    // prepare disableVideo callback\n    if (typeof self.options.disableVideo === 'string') {\n      self.options.disableVideo = new RegExp(self.options.disableVideo);\n    }\n    if (self.options.disableVideo instanceof RegExp) {\n      const disableVideoRegexp = self.options.disableVideo;\n      self.options.disableVideo = () => disableVideoRegexp.test(navigator.userAgent);\n    }\n    if (typeof self.options.disableVideo !== 'function') {\n      self.options.disableVideo = () => false;\n    }\n\n    // custom element to check if parallax in viewport\n    let elementInVP = self.options.elementInViewport;\n    // get first item from array\n    if (elementInVP && typeof elementInVP === 'object' && typeof elementInVP.length !== 'undefined') {\n      [elementInVP] = elementInVP;\n    }\n    // check if dom element\n    if (!(elementInVP instanceof Element)) {\n      elementInVP = null;\n    }\n    self.options.elementInViewport = elementInVP;\n    self.image = {\n      src: self.options.imgSrc || null,\n      $container: null,\n      useImgTag: false,\n      // 1. Position fixed is needed for the most of browsers because absolute position have glitches\n      // 2. On MacOS with smooth scroll there is a huge lags with absolute position - https://github.com/nk-o/jarallax/issues/75\n      // 3. Previously used 'absolute' for mobile devices. But we re-tested on iPhone 12 and 'fixed' position is working better, then 'absolute', so for now position is always 'fixed'\n      position: 'fixed'\n    };\n    if (self.initImg() && self.canInitParallax()) {\n      self.init();\n    }\n  }\n  css(el, styles) {\n    return css(el, styles);\n  }\n  extend(out, ...args) {\n    return extend$1(out, ...args);\n  }\n\n  // get window size and scroll position. Useful for extensions\n  getWindowData() {\n    const {\n      width,\n      height\n    } = getWindowSize();\n    return {\n      width,\n      height,\n      y: document.documentElement.scrollTop\n    };\n  }\n\n  // Jarallax functions\n  initImg() {\n    const self = this;\n\n    // find image element\n    let $imgElement = self.options.imgElement;\n    if ($imgElement && typeof $imgElement === 'string') {\n      $imgElement = self.$item.querySelector($imgElement);\n    }\n\n    // check if dom element\n    if (!($imgElement instanceof Element)) {\n      if (self.options.imgSrc) {\n        $imgElement = new Image();\n        $imgElement.src = self.options.imgSrc;\n      } else {\n        $imgElement = null;\n      }\n    }\n    if ($imgElement) {\n      if (self.options.keepImg) {\n        self.image.$item = $imgElement.cloneNode(true);\n      } else {\n        self.image.$item = $imgElement;\n        self.image.$itemParent = $imgElement.parentNode;\n      }\n      self.image.useImgTag = true;\n    }\n\n    // true if there is img tag\n    if (self.image.$item) {\n      return true;\n    }\n\n    // get image src\n    if (self.image.src === null) {\n      self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n      self.image.bgImage = self.css(self.$item, 'background-image');\n    }\n    return !(!self.image.bgImage || self.image.bgImage === 'none');\n  }\n  canInitParallax() {\n    return !this.options.disableParallax();\n  }\n  init() {\n    const self = this;\n    const containerStyles = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      overflow: 'hidden'\n    };\n    let imageStyles = {\n      pointerEvents: 'none',\n      transformStyle: 'preserve-3d',\n      backfaceVisibility: 'hidden'\n    };\n    if (!self.options.keepImg) {\n      // save default user styles\n      const curStyle = self.$item.getAttribute('style');\n      if (curStyle) {\n        self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n      }\n      if (self.image.useImgTag) {\n        const curImgStyle = self.image.$item.getAttribute('style');\n        if (curImgStyle) {\n          self.image.$item.setAttribute('data-jarallax-original-styles', curImgStyle);\n        }\n      }\n    }\n\n    // set relative position and z-index to the parent\n    if (self.css(self.$item, 'position') === 'static') {\n      self.css(self.$item, {\n        position: 'relative'\n      });\n    }\n    if (self.css(self.$item, 'z-index') === 'auto') {\n      self.css(self.$item, {\n        zIndex: 0\n      });\n    }\n\n    // container for parallax image\n    self.image.$container = document.createElement('div');\n    self.css(self.image.$container, containerStyles);\n    self.css(self.image.$container, {\n      'z-index': self.options.zIndex\n    });\n\n    // it will remove some image overlapping\n    // overlapping occur due to an image position fixed inside absolute position element\n    // needed only when background in fixed position\n    if (this.image.position === 'fixed') {\n      self.css(self.image.$container, {\n        '-webkit-clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)',\n        'clip-path': 'polygon(0 0, 100% 0, 100% 100%, 0 100%)'\n      });\n    }\n\n    // Add container unique ID.\n    self.image.$container.setAttribute('id', `jarallax-container-${self.instanceID}`);\n\n    // Add container class.\n    if (self.options.containerClass) {\n      self.image.$container.setAttribute('class', self.options.containerClass);\n    }\n    self.$item.appendChild(self.image.$container);\n\n    // use img tag\n    if (self.image.useImgTag) {\n      imageStyles = self.extend({\n        'object-fit': self.options.imgSize,\n        'object-position': self.options.imgPosition,\n        'max-width': 'none'\n      }, containerStyles, imageStyles);\n\n      // use div with background image\n    } else {\n      self.image.$item = document.createElement('div');\n      if (self.image.src) {\n        imageStyles = self.extend({\n          'background-position': self.options.imgPosition,\n          'background-size': self.options.imgSize,\n          'background-repeat': self.options.imgRepeat,\n          'background-image': self.image.bgImage || `url(\"${self.image.src}\")`\n        }, containerStyles, imageStyles);\n      }\n    }\n    if (self.options.type === 'opacity' || self.options.type === 'scale' || self.options.type === 'scale-opacity' || self.options.speed === 1) {\n      self.image.position = 'absolute';\n    }\n\n    // 1. Check if one of parents have transform style (without this check, scroll transform will be inverted if used parallax with position fixed)\n    //    discussion - https://github.com/nk-o/jarallax/issues/9\n    // 2. Check if parents have overflow scroll\n    if (self.image.position === 'fixed') {\n      const $parents = getParents(self.$item).filter(el => {\n        const styles = global$2.getComputedStyle(el);\n        const parentTransform = styles['-webkit-transform'] || styles['-moz-transform'] || styles.transform;\n        const overflowRegex = /(auto|scroll)/;\n        return parentTransform && parentTransform !== 'none' || overflowRegex.test(styles.overflow + styles['overflow-y'] + styles['overflow-x']);\n      });\n      self.image.position = $parents.length ? 'absolute' : 'fixed';\n    }\n\n    // add position to parallax block\n    imageStyles.position = self.image.position;\n\n    // insert parallax image\n    self.css(self.image.$item, imageStyles);\n    self.image.$container.appendChild(self.image.$item);\n\n    // set initial position and size\n    self.onResize();\n    self.onScroll(true);\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n\n    // remove default user background\n    if (self.css(self.$item, 'background-image') !== 'none') {\n      self.css(self.$item, {\n        'background-image': 'none'\n      });\n    }\n    addObserver(self);\n  }\n  destroy() {\n    const self = this;\n    removeObserver(self);\n\n    // return styles on container as before jarallax init\n    const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n    self.$item.removeAttribute('data-jarallax-original-styles');\n    // null occurs if there is no style tag before jarallax init\n    if (!originalStylesTag) {\n      self.$item.removeAttribute('style');\n    } else {\n      self.$item.setAttribute('style', originalStylesTag);\n    }\n    if (self.image.useImgTag) {\n      // return styles on img tag as before jarallax init\n      const originalStylesImgTag = self.image.$item.getAttribute('data-jarallax-original-styles');\n      self.image.$item.removeAttribute('data-jarallax-original-styles');\n      // null occurs if there is no style tag before jarallax init\n      if (!originalStylesImgTag) {\n        self.image.$item.removeAttribute('style');\n      } else {\n        self.image.$item.setAttribute('style', originalStylesTag);\n      }\n\n      // move img tag to its default position\n      if (self.image.$itemParent) {\n        self.image.$itemParent.appendChild(self.image.$item);\n      }\n    }\n\n    // remove additional dom elements\n    if (self.image.$container) {\n      self.image.$container.parentNode.removeChild(self.image.$container);\n    }\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // delete jarallax from item\n    delete self.$item.jarallax;\n  }\n  coverImage() {\n    const self = this;\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.image.$container.getBoundingClientRect();\n    const contH = rect.height;\n    const {\n      speed\n    } = self.options;\n    const isScroll = self.options.type === 'scroll' || self.options.type === 'scroll-opacity';\n    let scrollDist = 0;\n    let resultH = contH;\n    let resultMT = 0;\n\n    // scroll parallax\n    if (isScroll) {\n      // scroll distance and height for image\n      if (speed < 0) {\n        scrollDist = speed * Math.max(contH, wndH);\n        if (wndH < contH) {\n          scrollDist -= speed * (contH - wndH);\n        }\n      } else {\n        scrollDist = speed * (contH + wndH);\n      }\n\n      // size for scroll parallax\n      if (speed > 1) {\n        resultH = Math.abs(scrollDist - wndH);\n      } else if (speed < 0) {\n        resultH = scrollDist / speed + Math.abs(scrollDist);\n      } else {\n        resultH += (wndH - contH) * (1 - speed);\n      }\n      scrollDist /= 2;\n    }\n\n    // store scroll distance\n    self.parallaxScrollDistance = scrollDist;\n\n    // vertical center\n    if (isScroll) {\n      resultMT = (wndH - resultH) / 2;\n    } else {\n      resultMT = (contH - resultH) / 2;\n    }\n\n    // apply result to item\n    self.css(self.image.$item, {\n      height: `${resultH}px`,\n      marginTop: `${resultMT}px`,\n      left: self.image.position === 'fixed' ? `${rect.left}px` : '0',\n      width: `${rect.width}px`\n    });\n\n    // call onCoverImage event\n    if (self.options.onCoverImage) {\n      self.options.onCoverImage.call(self);\n    }\n\n    // return some useful data. Used in the video cover function\n    return {\n      image: {\n        height: resultH,\n        marginTop: resultMT\n      },\n      container: rect\n    };\n  }\n  isVisible() {\n    return this.isElementInViewport || false;\n  }\n  onScroll(force) {\n    const self = this;\n\n    // stop calculations if item is not in viewport\n    if (!force && !self.isVisible()) {\n      return;\n    }\n    const {\n      height: wndH\n    } = getWindowSize();\n    const rect = self.$item.getBoundingClientRect();\n    const contT = rect.top;\n    const contH = rect.height;\n    const styles = {};\n\n    // calculate parallax helping variables\n    const beforeTop = Math.max(0, contT);\n    const beforeTopEnd = Math.max(0, contH + contT);\n    const afterTop = Math.max(0, -contT);\n    const beforeBottom = Math.max(0, contT + contH - wndH);\n    const beforeBottomEnd = Math.max(0, contH - (contT + contH - wndH));\n    const afterBottom = Math.max(0, -contT + wndH - contH);\n    const fromViewportCenter = 1 - 2 * ((wndH - contT) / (wndH + contH));\n\n    // calculate on how percent of section is visible\n    let visiblePercent = 1;\n    if (contH < wndH) {\n      visiblePercent = 1 - (afterTop || beforeBottom) / contH;\n    } else if (beforeTopEnd <= wndH) {\n      visiblePercent = beforeTopEnd / wndH;\n    } else if (beforeBottomEnd <= wndH) {\n      visiblePercent = beforeBottomEnd / wndH;\n    }\n\n    // opacity\n    if (self.options.type === 'opacity' || self.options.type === 'scale-opacity' || self.options.type === 'scroll-opacity') {\n      styles.transform = 'translate3d(0,0,0)';\n      styles.opacity = visiblePercent;\n    }\n\n    // scale\n    if (self.options.type === 'scale' || self.options.type === 'scale-opacity') {\n      let scale = 1;\n      if (self.options.speed < 0) {\n        scale -= self.options.speed * visiblePercent;\n      } else {\n        scale += self.options.speed * (1 - visiblePercent);\n      }\n      styles.transform = `scale(${scale}) translate3d(0,0,0)`;\n    }\n\n    // scroll\n    if (self.options.type === 'scroll' || self.options.type === 'scroll-opacity') {\n      let positionY = self.parallaxScrollDistance * fromViewportCenter;\n\n      // fix if parallax block in absolute position\n      if (self.image.position === 'absolute') {\n        positionY -= contT;\n      }\n      styles.transform = `translate3d(0,${positionY}px,0)`;\n    }\n    self.css(self.image.$item, styles);\n\n    // call onScroll event\n    if (self.options.onScroll) {\n      self.options.onScroll.call(self, {\n        section: rect,\n        beforeTop,\n        beforeTopEnd,\n        afterTop,\n        beforeBottom,\n        beforeBottomEnd,\n        afterBottom,\n        visiblePercent,\n        fromViewportCenter\n      });\n    }\n  }\n  onResize() {\n    this.coverImage();\n  }\n}\n\n// global definition\nconst jarallax$1 = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (typeof HTMLElement === 'object' ? items instanceof HTMLElement : items && typeof items === 'object' && items !== null && items.nodeType === 1 && typeof items.nodeName === 'string') {\n    items = [items];\n  }\n  const len = items.length;\n  let k = 0;\n  let ret;\n  for (k; k < len; k += 1) {\n    if (typeof options === 'object' || typeof options === 'undefined') {\n      if (!items[k].jarallax) {\n        items[k].jarallax = new Jarallax(items[k], options);\n      }\n    } else if (items[k].jarallax) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].jarallax[options].apply(items[k].jarallax, args);\n    }\n    if (typeof ret !== 'undefined') {\n      return ret;\n    }\n  }\n  return items;\n};\njarallax$1.constructor = Jarallax;\n\n/*!\n * Video Worker v2.2.0 (https://github.com/nk-o/video-worker)\n * Copyright 2024 nK <https://nkdev.info>\n * Licensed under MIT (https://github.com/nk-o/video-worker/blob/master/LICENSE)\n */\n\nvar defaults = {\n  autoplay: false,\n  loop: false,\n  mute: false,\n  volume: 100,\n  showControls: true,\n  accessibilityHidden: false,\n  // start / end video time in seconds\n  startTime: 0,\n  endTime: 0\n};\n\n/**\n * Extend like jQuery.extend\n *\n * @param {Object} out - output object.\n * @param {...any} args - additional objects to extend.\n *\n * @returns {Object}\n */\nfunction extend(out, ...args) {\n  out = out || {};\n  Object.keys(args).forEach(i => {\n    if (!args[i]) {\n      return;\n    }\n    Object.keys(args[i]).forEach(key => {\n      out[key] = args[i][key];\n    });\n  });\n  return out;\n}\nlet ID = 0;\nclass VideoWorkerBase {\n  type = 'none';\n  constructor(url, options) {\n    const self = this;\n    self.url = url;\n    self.options_default = {\n      ...defaults\n    };\n    self.options = extend({}, self.options_default, options);\n\n    // check URL\n    self.videoID = self.constructor.parseURL(url);\n\n    // init\n    if (self.videoID) {\n      self.init();\n    }\n  }\n  isValid() {\n    return !!this.videoID;\n  }\n  init() {\n    const self = this;\n    self.ID = ID;\n    ID += 1;\n    self.playerID = `VideoWorker-${self.ID}`;\n  }\n\n  // events\n  on(name, callback) {\n    this.userEventsList = this.userEventsList || [];\n\n    // add new callback in events list\n    (this.userEventsList[name] || (this.userEventsList[name] = [])).push(callback);\n  }\n  off(name, callback) {\n    if (!this.userEventsList || !this.userEventsList[name]) {\n      return;\n    }\n    if (!callback) {\n      delete this.userEventsList[name];\n    } else {\n      this.userEventsList[name].forEach((val, key) => {\n        if (val === callback) {\n          this.userEventsList[name][key] = false;\n        }\n      });\n    }\n  }\n  fire(name, ...args) {\n    if (this.userEventsList && typeof this.userEventsList[name] !== 'undefined') {\n      this.userEventsList[name].forEach(val => {\n        // call with all arguments\n        if (val) {\n          val.apply(this, args);\n        }\n      });\n    }\n  }\n\n  /**\n   * Methods used in providers.\n   */\n  /* eslint-disable */\n  static parseURL(url) {\n    return false;\n  }\n  play(start) {}\n  pause() {}\n  mute() {}\n  unmute() {}\n  setVolume(volume = false) {}\n  getVolume(callback) {}\n  getMuted(callback) {}\n  setCurrentTime(currentTime = false) {}\n  getCurrentTime(callback) {}\n  getImageURL(callback) {}\n  getVideo(callback) {}\n  /* eslint-enable */\n}\n\n/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\nif (typeof window !== 'undefined') {\n  win = window;\n} else if (typeof global !== 'undefined') {\n  win = global;\n} else if (typeof self !== 'undefined') {\n  win = self;\n} else {\n  win = {};\n}\nvar global$1 = win;\n\n// Deferred\n// thanks http://stackoverflow.com/questions/18096715/implement-deferred-object-without-using-jquery\nfunction Deferred() {\n  this.doneCallbacks = [];\n  this.failCallbacks = [];\n}\nDeferred.prototype = {\n  execute(list, args) {\n    let i = list.length;\n    // eslint-disable-next-line no-param-reassign\n    args = Array.prototype.slice.call(args);\n    while (i) {\n      i -= 1;\n      list[i].apply(null, args);\n    }\n  },\n  resolve(...args) {\n    this.execute(this.doneCallbacks, args);\n  },\n  reject(...args) {\n    this.execute(this.failCallbacks, args);\n  },\n  done(callback) {\n    this.doneCallbacks.push(callback);\n  },\n  fail(callback) {\n    this.failCallbacks.push(callback);\n  }\n};\nlet YoutubeAPIadded = 0;\nlet loadingYoutubePlayer = 0;\nconst loadingYoutubeDefer = /*#__PURE__*/new Deferred();\nfunction loadAPI$1() {\n  if (YoutubeAPIadded) {\n    return;\n  }\n  YoutubeAPIadded = true;\n  const src = 'https://www.youtube.com/iframe_api';\n\n  // add script in head section\n  let tag = document.createElement('script');\n  let head = document.getElementsByTagName('head')[0];\n  tag.src = src;\n  head.appendChild(tag);\n  head = null;\n  tag = null;\n}\nfunction onAPIready$1(callback) {\n  // Listen for global YT player callback\n  if ((typeof global$1.YT === 'undefined' || global$1.YT.loaded === 0) && !loadingYoutubePlayer) {\n    // Prevents Ready event from being called twice\n    loadingYoutubePlayer = 1;\n\n    // Creates deferred so, other players know when to wait.\n    global$1.onYouTubeIframeAPIReady = function () {\n      global$1.onYouTubeIframeAPIReady = null;\n      loadingYoutubeDefer.resolve('done');\n      callback();\n    };\n  } else if (typeof global$1.YT === 'object' && global$1.YT.loaded === 1) {\n    callback();\n  } else {\n    loadingYoutubeDefer.done(() => {\n      callback();\n    });\n  }\n}\nclass VideoWorkerYoutube extends VideoWorkerBase {\n  type = 'youtube';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const regExp = /.*(?:youtu.be\\/|v\\/|u\\/\\w\\/|embed\\/|shorts\\/|watch\\?v=)([^#\\&\\?]*).*/;\n    const match = url.match(regExp);\n    return match && match[1].length === 11 ? match[1] : false;\n  }\n  init() {\n    super.init();\n    loadAPI$1();\n  }\n  play(start) {\n    const self = this;\n    if (!self.player || !self.player.playVideo) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.seekTo(start || 0);\n    }\n    if (global$1.YT.PlayerState.PLAYING !== self.player.getPlayerState()) {\n      // Don't play if video is already ended and with no loop.\n      if (self.options.endTime && !self.options.loop) {\n        self.getCurrentTime(seconds => {\n          if (seconds < self.options.endTime) {\n            self.player.playVideo();\n          }\n        });\n      } else {\n        self.player.playVideo();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player || !self.player.pauseVideo) {\n      return;\n    }\n    if (global$1.YT.PlayerState.PLAYING === self.player.getPlayerState()) {\n      self.player.pauseVideo();\n    }\n  }\n  mute() {\n    const self = this;\n    if (!self.player || !self.player.mute) {\n      return;\n    }\n    self.player.mute();\n  }\n  unmute() {\n    const self = this;\n    if (!self.player || !self.player.unMute) {\n      return;\n    }\n    self.player.unMute();\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number' || !self.player.setVolume) {\n      return;\n    }\n    self.player.setVolume(volume);\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.player.getVolume) {\n      callback(self.player.getVolume());\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.player.isMuted) {\n      callback(self.player.isMuted());\n    }\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number' || !self.player.seekTo) {\n      return;\n    }\n    self.player.seekTo(currentTime);\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player || !self.player.getCurrentTime) {\n      return;\n    }\n    callback(self.player.getCurrentTime());\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n    const availableSizes = ['maxresdefault', 'sddefault', 'hqdefault', '0'];\n    let step = 0;\n    const tempImg = new Image();\n    tempImg.onload = function () {\n      // if no thumbnail, youtube add their own image with width = 120px\n      if ((this.naturalWidth || this.width) !== 120 || step === availableSizes.length - 1) {\n        // ok\n        self.videoImage = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n        callback(self.videoImage);\n      } else {\n        // try another size\n        step += 1;\n        this.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n      }\n    };\n    tempImg.src = `https://img.youtube.com/vi/${self.videoID}/${availableSizes[step]}.jpg`;\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    onAPIready$1(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n      self.playerOptions = {\n        // GDPR Compliance.\n        host: 'https://www.youtube-nocookie.com',\n        videoId: self.videoID,\n        playerVars: {\n          autohide: 1,\n          rel: 0,\n          autoplay: 0,\n          // autoplay enable on mobile devices\n          playsinline: 1\n        }\n      };\n\n      // hide controls\n      if (!self.options.showControls) {\n        self.playerOptions.playerVars.iv_load_policy = 3;\n        self.playerOptions.playerVars.modestbranding = 1;\n        self.playerOptions.playerVars.controls = 0;\n        self.playerOptions.playerVars.showinfo = 0;\n        self.playerOptions.playerVars.disablekb = 1;\n      }\n\n      // events\n      let ytStarted;\n      let ytProgressInterval;\n      self.playerOptions.events = {\n        onReady(e) {\n          // mute\n          if (self.options.mute) {\n            e.target.mute();\n          } else if (typeof self.options.volume === 'number') {\n            e.target.setVolume(self.options.volume);\n          }\n\n          // autoplay\n          if (self.options.autoplay) {\n            self.play(self.options.startTime);\n          }\n          self.fire('ready', e);\n\n          // For seamless loops, set the endTime to 0.1 seconds less than the video's duration\n          // https://github.com/nk-o/video-worker/issues/2\n          if (self.options.loop && !self.options.endTime) {\n            const secondsOffset = 0.1;\n            self.options.endTime = self.player.getDuration() - secondsOffset;\n          }\n\n          // volumechange\n          setInterval(() => {\n            self.getVolume(volume => {\n              if (self.options.volume !== volume) {\n                self.options.volume = volume;\n                self.fire('volumechange', e);\n              }\n            });\n          }, 150);\n        },\n        onStateChange(e) {\n          // loop\n          if (self.options.loop && e.data === global$1.YT.PlayerState.ENDED) {\n            self.play(self.options.startTime);\n          }\n          if (!ytStarted && e.data === global$1.YT.PlayerState.PLAYING) {\n            ytStarted = 1;\n            self.fire('started', e);\n          }\n          if (e.data === global$1.YT.PlayerState.PLAYING) {\n            self.fire('play', e);\n          }\n          if (e.data === global$1.YT.PlayerState.PAUSED) {\n            self.fire('pause', e);\n          }\n          if (e.data === global$1.YT.PlayerState.ENDED) {\n            self.fire('ended', e);\n          }\n\n          // progress check\n          if (e.data === global$1.YT.PlayerState.PLAYING) {\n            ytProgressInterval = setInterval(() => {\n              self.fire('timeupdate', e);\n\n              // check for end of video and play again or stop\n              if (self.options.endTime && self.player.getCurrentTime() >= self.options.endTime) {\n                if (self.options.loop) {\n                  self.play(self.options.startTime);\n                } else {\n                  self.pause();\n                }\n              }\n            }, 150);\n          } else {\n            clearInterval(ytProgressInterval);\n          }\n        },\n        onError(e) {\n          self.fire('error', e);\n        }\n      };\n      const firstInit = !self.$video;\n      if (firstInit) {\n        const div = document.createElement('div');\n        div.setAttribute('id', self.playerID);\n        hiddenDiv.appendChild(div);\n        document.body.appendChild(hiddenDiv);\n      }\n      self.player = self.player || new global$1.YT.Player(self.playerID, self.playerOptions);\n      if (firstInit) {\n        self.$video = document.getElementById(self.playerID);\n\n        // add accessibility attributes\n        if (self.options.accessibilityHidden) {\n          self.$video.setAttribute('tabindex', '-1');\n          self.$video.setAttribute('aria-hidden', 'true');\n        }\n\n        // get video width and height\n        self.videoWidth = parseInt(self.$video.getAttribute('width'), 10) || 1280;\n        self.videoHeight = parseInt(self.$video.getAttribute('height'), 10) || 720;\n      }\n      callback(self.$video);\n    });\n  }\n}\nlet VimeoAPIadded = 0;\nlet loadingVimeoPlayer = 0;\nconst loadingVimeoDefer = /*#__PURE__*/new Deferred();\nfunction loadAPI() {\n  if (VimeoAPIadded) {\n    return;\n  }\n  VimeoAPIadded = true;\n\n  // Useful when Vimeo API added using RequireJS https://github.com/nk-o/video-worker/pull/7\n  if (typeof global$1.Vimeo !== 'undefined') {\n    return;\n  }\n  const src = 'https://player.vimeo.com/api/player.js';\n\n  // add script in head section\n  let tag = document.createElement('script');\n  let head = document.getElementsByTagName('head')[0];\n  tag.src = src;\n  head.appendChild(tag);\n  head = null;\n  tag = null;\n}\nfunction onAPIready(callback) {\n  if (typeof global$1.Vimeo === 'undefined' && !loadingVimeoPlayer) {\n    loadingVimeoPlayer = 1;\n    const vimeoInterval = setInterval(() => {\n      if (typeof global$1.Vimeo !== 'undefined') {\n        clearInterval(vimeoInterval);\n        loadingVimeoDefer.resolve('done');\n        callback();\n      }\n    }, 20);\n  } else if (typeof global$1.Vimeo !== 'undefined') {\n    callback();\n  } else {\n    loadingVimeoDefer.done(() => {\n      callback();\n    });\n  }\n}\nclass VideoWorkerVimeo extends VideoWorkerBase {\n  type = 'vimeo';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const regExp = /https?:\\/\\/(?:www\\.|player\\.)?vimeo.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|album\\/(\\d+)\\/video\\/|video\\/|)(\\d+)(?:$|\\/|\\?)/;\n    const match = url.match(regExp);\n    return match && match[3] ? match[3] : false;\n  }\n\n  // Try to extract a hash for private videos from the URL.\n  // Thanks to https://github.com/sampotts/plyr\n  static parseURLHash(url) {\n    /* This regex matches a hexadecimal hash if given in any of these forms:\n     *  - [https://player.]vimeo.com/video/{id}/{hash}[?params]\n     *  - [https://player.]vimeo.com/video/{id}?h={hash}[&params]\n     *  - [https://player.]vimeo.com/video/{id}?[params]&h={hash}\n     *  - video/{id}/{hash}\n     * If matched, the hash is available in capture group 4\n     */\n    const regex = /^.*(vimeo.com\\/|video\\/)(\\d+)(\\?.*&*h=|\\/)+([\\d,a-f]+)/;\n    const found = url.match(regex);\n    return found && found.length === 5 ? found[4] : null;\n  }\n  init() {\n    super.init();\n    loadAPI();\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.setCurrentTime(start);\n    }\n    self.player.getPaused().then(paused => {\n      if (paused) {\n        // Don't play if video is already ended and with no loop.\n        if (self.options.endTime && !self.options.loop) {\n          self.getCurrentTime(seconds => {\n            if (seconds < self.options.endTime) {\n              self.player.play();\n            }\n          });\n        } else {\n          self.player.play();\n        }\n      }\n    });\n  }\n  pause() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.player.getPaused().then(paused => {\n      if (!paused) {\n        self.player.pause();\n      }\n    });\n  }\n  mute() {\n    const self = this;\n    if (!self.player || !self.player.setVolume) {\n      return;\n    }\n    self.setVolume(0);\n  }\n  unmute() {\n    const self = this;\n    if (!self.player || !self.player.setVolume) {\n      return;\n    }\n\n    // In case the default volume is 0, we have to set 100 when unmute.\n    self.setVolume(self.options.volume || 100);\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number' || !self.player.setVolume) {\n      return;\n    }\n    self.player.setVolume(volume / 100);\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    if (self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(volume * 100);\n      });\n    }\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    if (self.player.getVolume) {\n      self.player.getVolume().then(volume => {\n        callback(!!volume);\n      });\n    }\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number' || !self.player.setCurrentTime) {\n      return;\n    }\n    self.player.setCurrentTime(currentTime);\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player || !self.player.getCurrentTime) {\n      return;\n    }\n    self.player.getCurrentTime().then(currentTime => {\n      callback(currentTime);\n    });\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n      return;\n    }\n\n    // We should provide width to get HQ thumbnail URL.\n    let width = global$1.innerWidth || 1920;\n    if (global$1.devicePixelRatio) {\n      width *= global$1.devicePixelRatio;\n    }\n    width = Math.min(width, 1920);\n    let request = new XMLHttpRequest();\n    // https://vimeo.com/api/oembed.json?url=https://vimeo.com/235212527\n    request.open('GET', `https://vimeo.com/api/oembed.json?url=${self.url}&width=${width}`, true);\n    request.onreadystatechange = function () {\n      if (this.readyState === 4) {\n        if (this.status >= 200 && this.status < 400) {\n          // Success!\n          const response = JSON.parse(this.responseText);\n          if (response.thumbnail_url) {\n            self.videoImage = response.thumbnail_url;\n            callback(self.videoImage);\n          }\n        }\n      }\n    };\n    request.send();\n    request = null;\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    onAPIready(() => {\n      let hiddenDiv;\n      if (!self.$video) {\n        hiddenDiv = document.createElement('div');\n        hiddenDiv.style.display = 'none';\n      }\n      self.playerOptions = {\n        // GDPR Compliance.\n        dnt: 1,\n        id: self.videoID,\n        autopause: 0,\n        transparent: 0,\n        autoplay: self.options.autoplay ? 1 : 0,\n        loop: self.options.loop ? 1 : 0,\n        muted: self.options.mute || self.options.volume === 0 ? 1 : 0\n      };\n\n      // private video hash\n      const urlHash = self.constructor.parseURLHash(self.url);\n      if (urlHash) {\n        self.playerOptions.h = urlHash;\n      }\n\n      // hide controls\n      if (!self.options.showControls) {\n        self.playerOptions.controls = 0;\n      }\n\n      // enable background option\n      if (!self.options.showControls && self.options.loop && self.options.autoplay) {\n        self.playerOptions.background = 1;\n      }\n      if (!self.$video) {\n        let playerOptionsString = '';\n        Object.keys(self.playerOptions).forEach(key => {\n          if (playerOptionsString !== '') {\n            playerOptionsString += '&';\n          }\n          playerOptionsString += `${key}=${encodeURIComponent(self.playerOptions[key])}`;\n        });\n\n        // we need to create iframe manually because when we create it using API\n        // js events won't triggers after iframe moved to another place\n        self.$video = document.createElement('iframe');\n        self.$video.setAttribute('id', self.playerID);\n        self.$video.setAttribute('src', `https://player.vimeo.com/video/${self.videoID}?${playerOptionsString}`);\n        self.$video.setAttribute('frameborder', '0');\n        self.$video.setAttribute('mozallowfullscreen', '');\n        self.$video.setAttribute('allowfullscreen', '');\n        self.$video.setAttribute('title', 'Vimeo video player');\n\n        // add accessibility attributes\n        if (self.options.accessibilityHidden) {\n          self.$video.setAttribute('tabindex', '-1');\n          self.$video.setAttribute('aria-hidden', 'true');\n        }\n        hiddenDiv.appendChild(self.$video);\n        document.body.appendChild(hiddenDiv);\n      }\n      self.player = self.player || new global$1.Vimeo.Player(self.$video, self.playerOptions);\n\n      // Since Vimeo removed the `volume` parameter, we have to set it manually.\n      if (!self.options.mute && typeof self.options.volume === 'number') {\n        self.setVolume(self.options.volume);\n      }\n\n      // set current time for autoplay\n      if (self.options.startTime && self.options.autoplay) {\n        self.player.setCurrentTime(self.options.startTime);\n      }\n\n      // get video width and height\n      self.player.getVideoWidth().then(width => {\n        self.videoWidth = width || 1280;\n      });\n      self.player.getVideoHeight().then(height => {\n        self.videoHeight = height || 720;\n      });\n\n      // events\n      let vmStarted;\n      self.player.on('timeupdate', e => {\n        if (!vmStarted) {\n          self.fire('started', e);\n          vmStarted = 1;\n        }\n        self.fire('timeupdate', e);\n\n        // check for end of video and play again or stop\n        if (self.options.endTime && e.seconds >= self.options.endTime) {\n          if (self.options.loop) {\n            self.play(self.options.startTime);\n          } else {\n            self.pause();\n          }\n        }\n      });\n      self.player.on('play', e => {\n        self.fire('play', e);\n\n        // check for the start time and start with it\n        if (self.options.startTime && e.seconds === 0) {\n          self.play(self.options.startTime);\n        }\n      });\n      self.player.on('pause', e => {\n        self.fire('pause', e);\n      });\n      self.player.on('ended', e => {\n        self.fire('ended', e);\n      });\n      self.player.on('loaded', e => {\n        self.fire('ready', e);\n      });\n      self.player.on('volumechange', e => {\n        self.getVolume(volume => {\n          self.options.volume = volume;\n        });\n        self.fire('volumechange', e);\n      });\n      self.player.on('error', e => {\n        self.fire('error', e);\n      });\n      callback(self.$video);\n    });\n  }\n}\nclass VideoWorkerLocal extends VideoWorkerBase {\n  type = 'local';\n  static parseURL(url) {\n    // eslint-disable-next-line no-useless-escape\n    const videoFormats = url.split(/,(?=mp4\\:|webm\\:|ogv\\:|ogg\\:)/);\n    const result = {};\n    let ready = 0;\n    videoFormats.forEach(val => {\n      // eslint-disable-next-line no-useless-escape\n      const match = val.match(/^(mp4|webm|ogv|ogg)\\:(.*)/);\n      if (match && match[1] && match[2]) {\n        // eslint-disable-next-line prefer-destructuring\n        result[match[1] === 'ogv' ? 'ogg' : match[1]] = match[2];\n        ready = 1;\n      }\n    });\n    return ready ? result : false;\n  }\n  play(start) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    if (typeof start !== 'undefined') {\n      self.player.currentTime = start;\n    }\n    if (self.player.paused) {\n      // Don't play if video is already ended and with no loop.\n      if (self.options.endTime && !self.options.loop) {\n        self.getCurrentTime(seconds => {\n          if (seconds < self.options.endTime) {\n            self.player.play();\n          }\n        });\n      } else {\n        self.player.play();\n      }\n    }\n  }\n  pause() {\n    const self = this;\n    if (!self.player || self.player.paused) {\n      return;\n    }\n    self.player.pause();\n  }\n  mute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.$video.muted = true;\n  }\n  unmute() {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    self.$video.muted = false;\n  }\n  setVolume(volume = false) {\n    const self = this;\n    if (!self.player || typeof volume !== 'number') {\n      return;\n    }\n    self.$video.volume = volume / 100;\n  }\n  getVolume(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(false);\n      return;\n    }\n    callback(self.$video.volume * 100);\n  }\n  getMuted(callback) {\n    const self = this;\n    if (!self.player) {\n      callback(null);\n      return;\n    }\n    callback(self.$video.muted);\n  }\n  setCurrentTime(currentTime = false) {\n    const self = this;\n    if (!self.player || typeof currentTime !== 'number') {\n      return;\n    }\n    self.$video.currentTime = currentTime;\n  }\n  getCurrentTime(callback) {\n    const self = this;\n    if (!self.player) {\n      return;\n    }\n    callback(self.player.currentTime);\n  }\n  getImageURL(callback) {\n    const self = this;\n    if (self.videoImage) {\n      callback(self.videoImage);\n    }\n  }\n  getVideo(callback) {\n    const self = this;\n\n    // return generated video block\n    if (self.$video) {\n      callback(self.$video);\n      return;\n    }\n\n    // generate new video block\n    let hiddenDiv;\n    if (!self.$video) {\n      hiddenDiv = document.createElement('div');\n      hiddenDiv.style.display = 'none';\n    }\n    function addSourceElement(element, src, type) {\n      const source = document.createElement('source');\n      source.src = src;\n      source.type = type;\n      element.appendChild(source);\n    }\n    if (!self.$video) {\n      self.$video = document.createElement('video');\n      self.player = self.$video;\n\n      // show controls\n      if (self.options.showControls) {\n        self.$video.controls = true;\n      }\n\n      // set volume\n      if (typeof self.options.volume === 'number') {\n        self.setVolume(self.options.volume);\n      }\n\n      // mute (it is required to mute after the volume set)\n      if (self.options.mute) {\n        self.mute();\n      }\n\n      // loop\n      if (self.options.loop) {\n        self.$video.loop = true;\n      }\n\n      // autoplay enable on mobile devices\n      self.$video.setAttribute('playsinline', '');\n      self.$video.setAttribute('webkit-playsinline', '');\n\n      // add accessibility attributes\n      if (self.options.accessibilityHidden) {\n        self.$video.setAttribute('tabindex', '-1');\n        self.$video.setAttribute('aria-hidden', 'true');\n      }\n      self.$video.setAttribute('id', self.playerID);\n      hiddenDiv.appendChild(self.$video);\n      document.body.appendChild(hiddenDiv);\n      Object.keys(self.videoID).forEach(key => {\n        addSourceElement(self.$video, self.videoID[key], `video/${key}`);\n      });\n    }\n    let locStarted;\n    self.player.addEventListener('playing', e => {\n      if (!locStarted) {\n        self.fire('started', e);\n      }\n      locStarted = 1;\n    });\n    self.player.addEventListener('timeupdate', function (e) {\n      self.fire('timeupdate', e);\n\n      // check for end of video and play again or stop\n      if (self.options.endTime && this.currentTime >= self.options.endTime) {\n        if (self.options.loop) {\n          self.play(self.options.startTime);\n        } else {\n          self.pause();\n        }\n      }\n    });\n    self.player.addEventListener('play', e => {\n      self.fire('play', e);\n    });\n    self.player.addEventListener('pause', e => {\n      self.fire('pause', e);\n    });\n    self.player.addEventListener('ended', e => {\n      self.fire('ended', e);\n    });\n    self.player.addEventListener('loadedmetadata', function () {\n      // get video width and height\n      self.videoWidth = this.videoWidth || 1280;\n      self.videoHeight = this.videoHeight || 720;\n      self.fire('ready');\n\n      // autoplay\n      if (self.options.autoplay) {\n        self.play(self.options.startTime);\n      }\n    });\n    self.player.addEventListener('volumechange', e => {\n      self.getVolume(volume => {\n        self.options.volume = volume;\n      });\n      self.fire('volumechange', e);\n    });\n    self.player.addEventListener('error', e => {\n      self.fire('error', e);\n    });\n    callback(self.$video);\n  }\n}\nfunction VideoWorker(url, options) {\n  let result = false;\n  Object.keys(VideoWorker.providers).forEach(key => {\n    if (!result && VideoWorker.providers[key].parseURL(url)) {\n      result = new VideoWorker.providers[key](url, options);\n    }\n  });\n  return result || new VideoWorkerBase(url, options);\n}\nVideoWorker.BaseClass = VideoWorkerBase;\nVideoWorker.providers = {\n  Youtube: VideoWorkerYoutube,\n  Vimeo: VideoWorkerVimeo,\n  Local: VideoWorkerLocal\n};\n\nfunction jarallaxVideo$1(jarallax = global$2.jarallax) {\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // append video after when block will be visible.\n  const defOnScroll = Jarallax.prototype.onScroll;\n  Jarallax.prototype.onScroll = function () {\n    const self = this;\n    defOnScroll.apply(self);\n    const isReady = !self.isVideoInserted && self.video && (!self.options.videoLazyLoading || self.isElementInViewport) && !self.options.disableVideo();\n    if (isReady) {\n      self.isVideoInserted = true;\n      self.video.getVideo(video => {\n        const $parent = video.parentNode;\n        self.css(video, {\n          position: self.image.position,\n          top: '0px',\n          left: '0px',\n          right: '0px',\n          bottom: '0px',\n          width: '100%',\n          height: '100%',\n          maxWidth: 'none',\n          maxHeight: 'none',\n          pointerEvents: 'none',\n          transformStyle: 'preserve-3d',\n          backfaceVisibility: 'hidden',\n          margin: 0,\n          zIndex: -1\n        });\n        self.$video = video;\n\n        // add Poster attribute to self-hosted video\n        if (self.video.type === 'local') {\n          if (self.image.src) {\n            self.$video.setAttribute('poster', self.image.src);\n          } else if (self.image.$item && self.image.$item.tagName === 'IMG' && self.image.$item.src) {\n            self.$video.setAttribute('poster', self.image.$item.src);\n          }\n        }\n\n        // add classname to video element\n        if (self.options.videoClass) {\n          self.$video.setAttribute('class', `${self.options.videoClass} ${self.options.videoClass}-${self.video.type}`);\n        }\n\n        // insert video tag\n        self.image.$container.appendChild(video);\n\n        // remove parent video element (created by VideoWorker)\n        $parent.parentNode.removeChild($parent);\n\n        // call onVideoInsert event\n        if (self.options.onVideoInsert) {\n          self.options.onVideoInsert.call(self);\n        }\n      });\n    }\n  };\n\n  // cover video\n  const defCoverImage = Jarallax.prototype.coverImage;\n  Jarallax.prototype.coverImage = function () {\n    const self = this;\n    const imageData = defCoverImage.apply(self);\n    const node = self.image.$item ? self.image.$item.nodeName : false;\n    if (imageData && self.video && node && (node === 'IFRAME' || node === 'VIDEO')) {\n      let h = imageData.image.height;\n      let w = h * self.image.width / self.image.height;\n      let ml = (imageData.container.width - w) / 2;\n      let mt = imageData.image.marginTop;\n      if (imageData.container.width > w) {\n        w = imageData.container.width;\n        h = w * self.image.height / self.image.width;\n        ml = 0;\n        mt += (imageData.image.height - h) / 2;\n      }\n\n      // add video height over than need to hide controls\n      if (node === 'IFRAME') {\n        h += 400;\n        mt -= 200;\n      }\n      self.css(self.$video, {\n        width: `${w}px`,\n        marginLeft: `${ml}px`,\n        height: `${h}px`,\n        marginTop: `${mt}px`\n      });\n    }\n    return imageData;\n  };\n\n  // init video\n  const defInitImg = Jarallax.prototype.initImg;\n  Jarallax.prototype.initImg = function () {\n    const self = this;\n    const defaultResult = defInitImg.apply(self);\n    if (!self.options.videoSrc) {\n      self.options.videoSrc = self.$item.getAttribute('data-jarallax-video') || null;\n    }\n    if (self.options.videoSrc) {\n      self.defaultInitImgResult = defaultResult;\n      return true;\n    }\n    return defaultResult;\n  };\n  const defCanInitParallax = Jarallax.prototype.canInitParallax;\n  Jarallax.prototype.canInitParallax = function () {\n    const self = this;\n    let defaultResult = defCanInitParallax.apply(self);\n    if (!self.options.videoSrc) {\n      return defaultResult;\n    }\n\n    // Init video api\n    const video = new VideoWorker(self.options.videoSrc, {\n      autoplay: true,\n      loop: self.options.videoLoop,\n      showControls: false,\n      accessibilityHidden: true,\n      startTime: self.options.videoStartTime || 0,\n      endTime: self.options.videoEndTime || 0,\n      mute: !self.options.videoVolume,\n      volume: self.options.videoVolume || 0\n    });\n\n    // call onVideoWorkerInit event\n    if (self.options.onVideoWorkerInit) {\n      self.options.onVideoWorkerInit.call(self, video);\n    }\n    function resetDefaultImage() {\n      if (self.image.$default_item) {\n        self.image.$item = self.image.$default_item;\n        self.image.$item.style.display = 'block';\n\n        // set image width and height\n        self.coverImage();\n        self.onScroll();\n      }\n    }\n    if (video.isValid()) {\n      // Force enable parallax.\n      // When the parallax disabled on mobile devices, we still need to display videos.\n      // https://github.com/nk-o/jarallax/issues/159\n      if (this.options.disableParallax()) {\n        defaultResult = true;\n        self.image.position = 'absolute';\n        self.options.type = 'scroll';\n        self.options.speed = 1;\n      }\n\n      // if parallax will not be inited, we can add thumbnail on background.\n      if (!defaultResult) {\n        if (!self.defaultInitImgResult) {\n          video.getImageURL(url => {\n            // save default user styles\n            const curStyle = self.$item.getAttribute('style');\n            if (curStyle) {\n              self.$item.setAttribute('data-jarallax-original-styles', curStyle);\n            }\n\n            // set new background\n            self.css(self.$item, {\n              'background-image': `url(\"${url}\")`,\n              'background-position': 'center',\n              'background-size': 'cover'\n            });\n          });\n        }\n\n        // init video\n      } else {\n        video.on('ready', () => {\n          if (self.options.videoPlayOnlyVisible) {\n            const oldOnScroll = self.onScroll;\n            self.onScroll = function () {\n              oldOnScroll.apply(self);\n              if (!self.videoError && (self.options.videoLoop || !self.options.videoLoop && !self.videoEnded)) {\n                if (self.isVisible()) {\n                  video.play();\n                } else {\n                  video.pause();\n                }\n              }\n            };\n          } else {\n            video.play();\n          }\n        });\n        video.on('started', () => {\n          self.image.$default_item = self.image.$item;\n          self.image.$item = self.$video;\n\n          // set video width and height\n          self.image.width = self.video.videoWidth || 1280;\n          self.image.height = self.video.videoHeight || 720;\n          self.coverImage();\n          self.onScroll();\n\n          // hide image\n          if (self.image.$default_item) {\n            self.image.$default_item.style.display = 'none';\n          }\n        });\n        video.on('ended', () => {\n          self.videoEnded = true;\n          if (!self.options.videoLoop) {\n            // show default image if Loop disabled.\n            resetDefaultImage();\n          }\n        });\n        video.on('error', () => {\n          self.videoError = true;\n\n          // show default image if video loading error.\n          resetDefaultImage();\n        });\n        self.video = video;\n\n        // set image if not exists\n        if (!self.defaultInitImgResult) {\n          // set empty image on self-hosted video if not defined\n          self.image.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n          if (video.type !== 'local') {\n            video.getImageURL(url => {\n              self.image.bgImage = `url(\"${url}\")`;\n              self.init();\n            });\n            return false;\n          }\n        }\n      }\n    }\n    return defaultResult;\n  };\n\n  // Destroy video parallax\n  const defDestroy = Jarallax.prototype.destroy;\n  Jarallax.prototype.destroy = function () {\n    const self = this;\n    if (self.image.$default_item) {\n      self.image.$item = self.image.$default_item;\n      delete self.image.$default_item;\n    }\n    defDestroy.apply(self);\n  };\n}\n\nfunction jarallaxElement$1(jarallax = global$2.jarallax) {\n  // eslint-disable-next-line no-console\n  console.warn(\"Jarallax Element extension is DEPRECATED, please, avoid using it. We recommend you look at something like `lax.js` library <https://github.com/alexfoxy/lax.js>. It is much more powerful and has a less code (in cases when you don't want to add parallax backgrounds).\");\n  if (typeof jarallax === 'undefined') {\n    return;\n  }\n  const Jarallax = jarallax.constructor;\n\n  // redefine default methods\n  ['initImg', 'canInitParallax', 'init', 'destroy', 'coverImage', 'isVisible', 'onScroll', 'onResize'].forEach(key => {\n    const def = Jarallax.prototype[key];\n    Jarallax.prototype[key] = function (...args) {\n      const self = this;\n      if (key === 'initImg' && self.$item.getAttribute('data-jarallax-element') !== null) {\n        self.options.type = 'element';\n        self.pureOptions.speed = self.$item.getAttribute('data-jarallax-element') || '100';\n      }\n      if (self.options.type !== 'element') {\n        return def.apply(self, args);\n      }\n      self.pureOptions.threshold = self.$item.getAttribute('data-threshold') || '';\n      switch (key) {\n        case 'init':\n          {\n            const speedArr = `${self.pureOptions.speed}`.split(' ');\n            self.options.speed = self.pureOptions.speed || 0;\n            self.options.speedY = speedArr[0] ? parseFloat(speedArr[0]) : 0;\n            self.options.speedX = speedArr[1] ? parseFloat(speedArr[1]) : 0;\n            const thresholdArr = self.pureOptions.threshold.split(' ');\n            self.options.thresholdY = thresholdArr[0] ? parseFloat(thresholdArr[0]) : null;\n            self.options.thresholdX = thresholdArr[1] ? parseFloat(thresholdArr[1]) : null;\n            def.apply(self, args);\n\n            // restore background image if available.\n            const originalStylesTag = self.$item.getAttribute('data-jarallax-original-styles');\n            if (originalStylesTag) {\n              self.$item.setAttribute('style', originalStylesTag);\n            }\n            return true;\n          }\n        case 'onResize':\n          {\n            const defTransform = self.css(self.$item, 'transform');\n            self.css(self.$item, {\n              transform: ''\n            });\n            const rect = self.$item.getBoundingClientRect();\n            self.itemData = {\n              width: rect.width,\n              height: rect.height,\n              y: rect.top + self.getWindowData().y,\n              x: rect.left\n            };\n            self.css(self.$item, {\n              transform: defTransform\n            });\n            break;\n          }\n        case 'onScroll':\n          {\n            const wnd = self.getWindowData();\n            const centerPercent = (wnd.y + wnd.height / 2 - self.itemData.y - self.itemData.height / 2) / (wnd.height / 2);\n            const moveY = centerPercent * self.options.speedY;\n            const moveX = centerPercent * self.options.speedX;\n            let my = moveY;\n            let mx = moveX;\n            if (self.options.thresholdY !== null && moveY > self.options.thresholdY) my = 0;\n            if (self.options.thresholdX !== null && moveX > self.options.thresholdX) mx = 0;\n            self.css(self.$item, {\n              transform: `translate3d(${mx}px,${my}px,0)`\n            });\n            break;\n          }\n        case 'initImg':\n        case 'isVisible':\n        case 'coverImage':\n          return true;\n        // no default\n      }\n      return def.apply(self, args);\n    };\n  });\n}\n\nconst jarallax = jarallax$1;\nconst jarallaxVideo = function jarallaxVideo() {\n  return jarallaxVideo$1(jarallax);\n};\nconst jarallaxElement = function jarallaxElement() {\n  return jarallaxElement$1(jarallax);\n};\n\nexports.jarallax = jarallax;\nexports.jarallaxElement = jarallaxElement;\nexports.jarallaxVideo = jarallaxVideo;\n//# sourceMappingURL=jarallax.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvamFyYWxsYXgvZGlzdC9qYXJhbGxheC5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYyxTQUFTLGVBQWUsU0FBUztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUM7QUFDakMscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxtRUFBbUUsZ0JBQWdCOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWU7QUFDM0UsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG9CQUFvQixTQUFTO0FBQzdCLGlEQUFpRCxVQUFVO0FBQzNELGdCQUFnQixXQUFXO0FBQzNCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWEsR0FBRyxxQkFBcUI7QUFDN0Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlEQUFpRCxhQUFhLEdBQUcscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYSxHQUFHLHFCQUFxQjtBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUcsRUFBRSxLQUFLO0FBQ3RELDRDQUE0QyxHQUFHLElBQUksS0FBSztBQUN4RCw0Q0FBNEMsR0FBRyxhQUFhO0FBQzVELGlCQUFpQixHQUFHLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTLFNBQVMsTUFBTTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUksR0FBRyw0Q0FBNEM7QUFDdkYsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhLEdBQUcsb0JBQW9CO0FBQzlHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsSUFBSTtBQUN0RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLHlCQUF5QixFQUFFLHdCQUF3QixHQUFHLGdCQUFnQjtBQUNySDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCLHVCQUF1QixHQUFHO0FBQzFCLG1CQUFtQixFQUFFO0FBQ3JCLHNCQUFzQixHQUFHO0FBQ3pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxHQUFHLEtBQUssR0FBRztBQUNuRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rdXJhLXRhaWx3aW5kY3NzLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2phcmFsbGF4L2Rpc3QvamFyYWxsYXguY2pzPzAwOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBKYXJhbGxheCB2Mi4yLjAgKGh0dHBzOi8vZ2l0aHViLmNvbS9uay1vL2phcmFsbGF4KVxuICogQ29weXJpZ2h0IDIwMjQgbksgPGh0dHBzOi8vbmtkZXYuaW5mbz5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25rLW8vamFyYWxsYXgvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMkMSA9IHtcbiAgLy8gQmFzZSBwYXJhbGxheCBvcHRpb25zLlxuICB0eXBlOiAnc2Nyb2xsJyxcbiAgc3BlZWQ6IDAuNSxcbiAgY29udGFpbmVyQ2xhc3M6ICdqYXJhbGxheC1jb250YWluZXInLFxuICBpbWdTcmM6IG51bGwsXG4gIGltZ0VsZW1lbnQ6ICcuamFyYWxsYXgtaW1nJyxcbiAgaW1nU2l6ZTogJ2NvdmVyJyxcbiAgaW1nUG9zaXRpb246ICc1MCUgNTAlJyxcbiAgaW1nUmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAga2VlcEltZzogZmFsc2UsXG4gIGVsZW1lbnRJblZpZXdwb3J0OiBudWxsLFxuICB6SW5kZXg6IC0xMDAsXG4gIGRpc2FibGVQYXJhbGxheDogZmFsc2UsXG4gIC8vIENhbGxiYWNrcy5cbiAgb25TY3JvbGw6IG51bGwsXG4gIG9uSW5pdDogbnVsbCxcbiAgb25EZXN0cm95OiBudWxsLFxuICBvbkNvdmVySW1hZ2U6IG51bGwsXG4gIC8vIFZpZGVvIG9wdGlvbnMuXG4gIHZpZGVvQ2xhc3M6ICdqYXJhbGxheC12aWRlbycsXG4gIHZpZGVvU3JjOiBudWxsLFxuICB2aWRlb1N0YXJ0VGltZTogMCxcbiAgdmlkZW9FbmRUaW1lOiAwLFxuICB2aWRlb1ZvbHVtZTogMCxcbiAgdmlkZW9Mb29wOiB0cnVlLFxuICB2aWRlb1BsYXlPbmx5VmlzaWJsZTogdHJ1ZSxcbiAgdmlkZW9MYXp5TG9hZGluZzogdHJ1ZSxcbiAgZGlzYWJsZVZpZGVvOiBmYWxzZSxcbiAgLy8gVmlkZW8gY2FsbGJhY2tzLlxuICBvblZpZGVvSW5zZXJ0OiBudWxsLFxuICBvblZpZGVvV29ya2VySW5pdDogbnVsbFxufTtcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgd2luJDE7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luJDEgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbiQxID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luJDEgPSBzZWxmO1xufSBlbHNlIHtcbiAgd2luJDEgPSB7fTtcbn1cbnZhciBnbG9iYWwkMiA9IHdpbiQxO1xuXG4vKipcbiAqIEFkZCBzdHlsZXMgdG8gZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gc3R5bGVzIC0gc3R5bGVzIGxpc3QuXG4gKlxuICogQHJldHVybnMge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNzcyhlbCwgc3R5bGVzKSB7XG4gIGlmICh0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnbG9iYWwkMi5nZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlcyk7XG4gIH1cbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgZWwuc3R5bGVba2V5XSA9IHN0eWxlc1trZXldO1xuICB9KTtcbiAgcmV0dXJuIGVsO1xufVxuXG4vKipcbiAqIEV4dGVuZCBsaWtlIGpRdWVyeS5leHRlbmRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0IC0gb3V0cHV0IG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uYW55fSBhcmdzIC0gYWRkaXRpb25hbCBvYmplY3RzIHRvIGV4dGVuZC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBleHRlbmQkMShvdXQsIC4uLmFyZ3MpIHtcbiAgb3V0ID0gb3V0IHx8IHt9O1xuICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGkgPT4ge1xuICAgIGlmICghYXJnc1tpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhhcmdzW2ldKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogR2V0IGFsbCBwYXJlbnRzIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIERPTSBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50cyhlbGVtKSB7XG4gIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKGVsZW0ucGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGVsZW0gPSBlbGVtLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIHBhcmVudHMucHVzaChlbGVtKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbi8qKlxuICogRG9jdW1lbnQgcmVhZHkgY2FsbGJhY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQgb25jZSBEb2N1bWVudCByZWFkeS5cbiAqL1xuZnVuY3Rpb24gcmVhZHkoY2FsbGJhY2spIHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgIC8vIEFscmVhZHkgcmVhZHkgb3IgaW50ZXJhY3RpdmUsIGV4ZWN1dGUgY2FsbGJhY2tcbiAgICBjYWxsYmFjaygpO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYWxsYmFjaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3Qge1xuICBuYXZpZ2F0b3I6IG5hdmlnYXRvciQxXG59ID0gZ2xvYmFsJDI7XG5jb25zdCBtb2JpbGVBZ2VudCA9IC8qI19fUFVSRV9fKi8gL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvciQxLnVzZXJBZ2VudCk7XG5mdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuIG1vYmlsZUFnZW50O1xufVxuXG5sZXQgd25kVztcbmxldCB3bmRIO1xubGV0ICRkZXZpY2VIZWxwZXI7XG5cbi8qKlxuICogVGhlIG1vc3QgcG9wdWxhciBtb2JpbGUgYnJvd3NlcnMgY2hhbmdlcyBoZWlnaHQgYWZ0ZXIgcGFnZSBzY3JvbGwgYW5kIHRoaXMgZ2VuZXJhdGVzIGltYWdlIGp1bXBpbmcuXG4gKiBXZSBjYW4gZml4IGl0IHVzaW5nIHRoaXMgd29ya2Fyb3VuZCB3aXRoIHZoIHVuaXRzLlxuICovXG5mdW5jdGlvbiBnZXREZXZpY2VIZWlnaHQoKSB7XG4gIGlmICghJGRldmljZUhlbHBlciAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgJGRldmljZUhlbHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICRkZXZpY2VIZWxwZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTk5OTlweDsgbGVmdDogMDsgaGVpZ2h0OiAxMDB2aDsgd2lkdGg6IDA7JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCRkZXZpY2VIZWxwZXIpO1xuICB9XG4gIHJldHVybiAoJGRldmljZUhlbHBlciA/ICRkZXZpY2VIZWxwZXIuY2xpZW50SGVpZ2h0IDogMCkgfHwgZ2xvYmFsJDIuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdpbmRvd0hlaWdodCgpIHtcbiAgd25kVyA9IGdsb2JhbCQyLmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBpZiAoaXNNb2JpbGUoKSkge1xuICAgIHduZEggPSBnZXREZXZpY2VIZWlnaHQoKTtcbiAgfSBlbHNlIHtcbiAgICB3bmRIID0gZ2xvYmFsJDIuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxufVxudXBkYXRlV2luZG93SGVpZ2h0KCk7XG5nbG9iYWwkMi5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVXaW5kb3dIZWlnaHQpO1xuZ2xvYmFsJDIuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB1cGRhdGVXaW5kb3dIZWlnaHQpO1xuZ2xvYmFsJDIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHVwZGF0ZVdpbmRvd0hlaWdodCk7XG5yZWFkeSgoKSA9PiB7XG4gIHVwZGF0ZVdpbmRvd0hlaWdodCgpO1xufSk7XG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplKCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3bmRXLFxuICAgIGhlaWdodDogd25kSFxuICB9O1xufVxuXG4vLyBMaXN0IHdpdGggYWxsIGphcmFsbGF4IGluc3RhbmNlc1xuLy8gbmVlZCB0byByZW5kZXIgYWxsIGluIG9uZSBzY3JvbGwvcmVzaXplIGV2ZW50LlxuY29uc3QgamFyYWxsYXhMaXN0ID0gW107XG5mdW5jdGlvbiB1cGRhdGVQYXJhbGxheCgpIHtcbiAgaWYgKCFqYXJhbGxheExpc3QubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICB3aWR0aDogd25kVyxcbiAgICBoZWlnaHQ6IHduZEhcbiAgfSA9IGdldFdpbmRvd1NpemUoKTtcbiAgamFyYWxsYXhMaXN0LmZvckVhY2goKGRhdGEsIGspID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZSxcbiAgICAgIG9sZERhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWluc3RhbmNlLmlzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudFJlY3QgPSBpbnN0YW5jZS4kaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBuZXdEYXRhID0ge1xuICAgICAgd2lkdGg6IGNsaWVudFJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IGNsaWVudFJlY3QuaGVpZ2h0LFxuICAgICAgdG9wOiBjbGllbnRSZWN0LnRvcCxcbiAgICAgIGJvdHRvbTogY2xpZW50UmVjdC5ib3R0b20sXG4gICAgICB3bmRXLFxuICAgICAgd25kSFxuICAgIH07XG4gICAgY29uc3QgaXNSZXNpemVkID0gIW9sZERhdGEgfHwgb2xkRGF0YS53bmRXICE9PSBuZXdEYXRhLnduZFcgfHwgb2xkRGF0YS53bmRIICE9PSBuZXdEYXRhLnduZEggfHwgb2xkRGF0YS53aWR0aCAhPT0gbmV3RGF0YS53aWR0aCB8fCBvbGREYXRhLmhlaWdodCAhPT0gbmV3RGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgaXNTY3JvbGxlZCA9IGlzUmVzaXplZCB8fCAhb2xkRGF0YSB8fCBvbGREYXRhLnRvcCAhPT0gbmV3RGF0YS50b3AgfHwgb2xkRGF0YS5ib3R0b20gIT09IG5ld0RhdGEuYm90dG9tO1xuICAgIGphcmFsbGF4TGlzdFtrXS5vbGREYXRhID0gbmV3RGF0YTtcbiAgICBpZiAoaXNSZXNpemVkKSB7XG4gICAgICBpbnN0YW5jZS5vblJlc2l6ZSgpO1xuICAgIH1cbiAgICBpZiAoaXNTY3JvbGxlZCkge1xuICAgICAgaW5zdGFuY2Uub25TY3JvbGwoKTtcbiAgICB9XG4gIH0pO1xuICBnbG9iYWwkMi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUGFyYWxsYXgpO1xufVxuY29uc3QgdmlzaWJpbGl0eU9ic2VydmVyID0gLyojX19QVVJFX18qL25ldyBnbG9iYWwkMi5JbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBlbnRyeS50YXJnZXQuamFyYWxsYXguaXNFbGVtZW50SW5WaWV3cG9ydCA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICB9KTtcbn0sIHtcbiAgLy8gV2UgaGF2ZSB0byBzdGFydCBwYXJhbGxheCBjYWxjdWxhdGlvbiBiZWZvcmUgdGhlIGJsb2NrIGlzIGluIHZpZXdcbiAgLy8gdG8gcHJldmVudCBwb3NzaWJsZSBwYXJhbGxheCBqdW1waW5nLlxuICByb290TWFyZ2luOiAnNTBweCdcbn0pO1xuZnVuY3Rpb24gYWRkT2JzZXJ2ZXIoaW5zdGFuY2UpIHtcbiAgamFyYWxsYXhMaXN0LnB1c2goe1xuICAgIGluc3RhbmNlXG4gIH0pO1xuICBpZiAoamFyYWxsYXhMaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIGdsb2JhbCQyLnJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVQYXJhbGxheCk7XG4gIH1cbiAgdmlzaWJpbGl0eU9ic2VydmVyLm9ic2VydmUoaW5zdGFuY2Uub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydCB8fCBpbnN0YW5jZS4kaXRlbSk7XG59XG5mdW5jdGlvbiByZW1vdmVPYnNlcnZlcihpbnN0YW5jZSkge1xuICBqYXJhbGxheExpc3QuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgaWYgKGRhdGEuaW5zdGFuY2UuaW5zdGFuY2VJRCA9PT0gaW5zdGFuY2UuaW5zdGFuY2VJRCkge1xuICAgICAgamFyYWxsYXhMaXN0LnNwbGljZShrZXksIDEpO1xuICAgIH1cbiAgfSk7XG4gIHZpc2liaWxpdHlPYnNlcnZlci51bm9ic2VydmUoaW5zdGFuY2Uub3B0aW9ucy5lbGVtZW50SW5WaWV3cG9ydCB8fCBpbnN0YW5jZS4kaXRlbSk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmNvbnN0IHtcbiAgbmF2aWdhdG9yXG59ID0gZ2xvYmFsJDI7XG5sZXQgaW5zdGFuY2VJRCA9IDA7XG5cbi8vIEphcmFsbGF4IGNsYXNzXG5jbGFzcyBKYXJhbGxheCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJPcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5pbnN0YW5jZUlEID0gaW5zdGFuY2VJRDtcbiAgICBpbnN0YW5jZUlEICs9IDE7XG4gICAgc2VsZi4kaXRlbSA9IGl0ZW07XG4gICAgc2VsZi5kZWZhdWx0cyA9IHtcbiAgICAgIC4uLmRlZmF1bHRzJDFcbiAgICB9O1xuXG4gICAgLy8gcHJlcGFyZSBkYXRhLW9wdGlvbnNcbiAgICBjb25zdCBkYXRhT3B0aW9ucyA9IHNlbGYuJGl0ZW0uZGF0YXNldCB8fCB7fTtcbiAgICBjb25zdCBwdXJlRGF0YU9wdGlvbnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhkYXRhT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgbG93ZXJDYXNlT3B0aW9uID0ga2V5LnN1YnN0cigwLCAxKS50b0xvd2VyQ2FzZSgpICsga2V5LnN1YnN0cigxKTtcbiAgICAgIGlmIChsb3dlckNhc2VPcHRpb24gJiYgdHlwZW9mIHNlbGYuZGVmYXVsdHNbbG93ZXJDYXNlT3B0aW9uXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHVyZURhdGFPcHRpb25zW2xvd2VyQ2FzZU9wdGlvbl0gPSBkYXRhT3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYub3B0aW9ucyA9IHNlbGYuZXh0ZW5kKHt9LCBzZWxmLmRlZmF1bHRzLCBwdXJlRGF0YU9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgICBzZWxmLnB1cmVPcHRpb25zID0gc2VsZi5leHRlbmQoe30sIHNlbGYub3B0aW9ucyk7XG5cbiAgICAvLyBwcmVwYXJlICd0cnVlJyBhbmQgJ2ZhbHNlJyBzdHJpbmdzIHRvIGJvb2xlYW5cbiAgICBPYmplY3Qua2V5cyhzZWxmLm9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChzZWxmLm9wdGlvbnNba2V5XSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHNlbGYub3B0aW9uc1trZXldID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZi5vcHRpb25zW2tleV0gPT09ICdmYWxzZScpIHtcbiAgICAgICAgc2VsZi5vcHRpb25zW2tleV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpeCBzcGVlZCBvcHRpb24gWy0xLjAsIDIuMF1cbiAgICBzZWxmLm9wdGlvbnMuc3BlZWQgPSBNYXRoLm1pbigyLCBNYXRoLm1heCgtMSwgcGFyc2VGbG9hdChzZWxmLm9wdGlvbnMuc3BlZWQpKSk7XG5cbiAgICAvLyBwcmVwYXJlIGRpc2FibGVQYXJhbGxheCBjYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSBuZXcgUmVnRXhwKHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXgpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgY29uc3QgZGlzYWJsZVBhcmFsbGF4UmVnZXhwID0gc2VsZi5vcHRpb25zLmRpc2FibGVQYXJhbGxheDtcbiAgICAgIHNlbGYub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXggPSAoKSA9PiBkaXNhYmxlUGFyYWxsYXhSZWdleHAudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVBhcmFsbGF4ID0gKCkgPT4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBkaXNhYmxlVmlkZW8gY2FsbGJhY2tcbiAgICBpZiAodHlwZW9mIHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvID0gbmV3IFJlZ0V4cChzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvKTtcbiAgICB9XG4gICAgaWYgKHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW8gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIGNvbnN0IGRpc2FibGVWaWRlb1JlZ2V4cCA9IHNlbGYub3B0aW9ucy5kaXNhYmxlVmlkZW87XG4gICAgICBzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvID0gKCkgPT4gZGlzYWJsZVZpZGVvUmVnZXhwLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2VsZi5vcHRpb25zLmRpc2FibGVWaWRlbyA9ICgpID0+IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGN1c3RvbSBlbGVtZW50IHRvIGNoZWNrIGlmIHBhcmFsbGF4IGluIHZpZXdwb3J0XG4gICAgbGV0IGVsZW1lbnRJblZQID0gc2VsZi5vcHRpb25zLmVsZW1lbnRJblZpZXdwb3J0O1xuICAgIC8vIGdldCBmaXJzdCBpdGVtIGZyb20gYXJyYXlcbiAgICBpZiAoZWxlbWVudEluVlAgJiYgdHlwZW9mIGVsZW1lbnRJblZQID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZWxlbWVudEluVlAubGVuZ3RoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgW2VsZW1lbnRJblZQXSA9IGVsZW1lbnRJblZQO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBkb20gZWxlbWVudFxuICAgIGlmICghKGVsZW1lbnRJblZQIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnRJblZQID0gbnVsbDtcbiAgICB9XG4gICAgc2VsZi5vcHRpb25zLmVsZW1lbnRJblZpZXdwb3J0ID0gZWxlbWVudEluVlA7XG4gICAgc2VsZi5pbWFnZSA9IHtcbiAgICAgIHNyYzogc2VsZi5vcHRpb25zLmltZ1NyYyB8fCBudWxsLFxuICAgICAgJGNvbnRhaW5lcjogbnVsbCxcbiAgICAgIHVzZUltZ1RhZzogZmFsc2UsXG4gICAgICAvLyAxLiBQb3NpdGlvbiBmaXhlZCBpcyBuZWVkZWQgZm9yIHRoZSBtb3N0IG9mIGJyb3dzZXJzIGJlY2F1c2UgYWJzb2x1dGUgcG9zaXRpb24gaGF2ZSBnbGl0Y2hlc1xuICAgICAgLy8gMi4gT24gTWFjT1Mgd2l0aCBzbW9vdGggc2Nyb2xsIHRoZXJlIGlzIGEgaHVnZSBsYWdzIHdpdGggYWJzb2x1dGUgcG9zaXRpb24gLSBodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9pc3N1ZXMvNzVcbiAgICAgIC8vIDMuIFByZXZpb3VzbHkgdXNlZCAnYWJzb2x1dGUnIGZvciBtb2JpbGUgZGV2aWNlcy4gQnV0IHdlIHJlLXRlc3RlZCBvbiBpUGhvbmUgMTIgYW5kICdmaXhlZCcgcG9zaXRpb24gaXMgd29ya2luZyBiZXR0ZXIsIHRoZW4gJ2Fic29sdXRlJywgc28gZm9yIG5vdyBwb3NpdGlvbiBpcyBhbHdheXMgJ2ZpeGVkJ1xuICAgICAgcG9zaXRpb246ICdmaXhlZCdcbiAgICB9O1xuICAgIGlmIChzZWxmLmluaXRJbWcoKSAmJiBzZWxmLmNhbkluaXRQYXJhbGxheCgpKSB7XG4gICAgICBzZWxmLmluaXQoKTtcbiAgICB9XG4gIH1cbiAgY3NzKGVsLCBzdHlsZXMpIHtcbiAgICByZXR1cm4gY3NzKGVsLCBzdHlsZXMpO1xuICB9XG4gIGV4dGVuZChvdXQsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gZXh0ZW5kJDEob3V0LCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8vIGdldCB3aW5kb3cgc2l6ZSBhbmQgc2Nyb2xsIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGV4dGVuc2lvbnNcbiAgZ2V0V2luZG93RGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRXaW5kb3dTaXplKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cblxuICAvLyBKYXJhbGxheCBmdW5jdGlvbnNcbiAgaW5pdEltZygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIGZpbmQgaW1hZ2UgZWxlbWVudFxuICAgIGxldCAkaW1nRWxlbWVudCA9IHNlbGYub3B0aW9ucy5pbWdFbGVtZW50O1xuICAgIGlmICgkaW1nRWxlbWVudCAmJiB0eXBlb2YgJGltZ0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAkaW1nRWxlbWVudCA9IHNlbGYuJGl0ZW0ucXVlcnlTZWxlY3RvcigkaW1nRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZG9tIGVsZW1lbnRcbiAgICBpZiAoISgkaW1nRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmltZ1NyYykge1xuICAgICAgICAkaW1nRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAkaW1nRWxlbWVudC5zcmMgPSBzZWxmLm9wdGlvbnMuaW1nU3JjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGltZ0VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGltZ0VsZW1lbnQpIHtcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMua2VlcEltZykge1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtID0gJGltZ0VsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9ICRpbWdFbGVtZW50O1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtUGFyZW50ID0gJGltZ0VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuaW1hZ2UudXNlSW1nVGFnID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyB0cnVlIGlmIHRoZXJlIGlzIGltZyB0YWdcbiAgICBpZiAoc2VsZi5pbWFnZS4kaXRlbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGltYWdlIHNyY1xuICAgIGlmIChzZWxmLmltYWdlLnNyYyA9PT0gbnVsbCkge1xuICAgICAgc2VsZi5pbWFnZS5zcmMgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JztcbiAgICAgIHNlbGYuaW1hZ2UuYmdJbWFnZSA9IHNlbGYuY3NzKHNlbGYuJGl0ZW0sICdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgfVxuICAgIHJldHVybiAhKCFzZWxmLmltYWdlLmJnSW1hZ2UgfHwgc2VsZi5pbWFnZS5iZ0ltYWdlID09PSAnbm9uZScpO1xuICB9XG4gIGNhbkluaXRQYXJhbGxheCgpIHtcbiAgICByZXR1cm4gIXRoaXMub3B0aW9ucy5kaXNhYmxlUGFyYWxsYXgoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlcyA9IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgIH07XG4gICAgbGV0IGltYWdlU3R5bGVzID0ge1xuICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgdHJhbnNmb3JtU3R5bGU6ICdwcmVzZXJ2ZS0zZCcsXG4gICAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICdoaWRkZW4nXG4gICAgfTtcbiAgICBpZiAoIXNlbGYub3B0aW9ucy5rZWVwSW1nKSB7XG4gICAgICAvLyBzYXZlIGRlZmF1bHQgdXNlciBzdHlsZXNcbiAgICAgIGNvbnN0IGN1clN0eWxlID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBpZiAoY3VyU3R5bGUpIHtcbiAgICAgICAgc2VsZi4kaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJywgY3VyU3R5bGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYuaW1hZ2UudXNlSW1nVGFnKSB7XG4gICAgICAgIGNvbnN0IGN1ckltZ1N0eWxlID0gc2VsZi5pbWFnZS4kaXRlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChjdXJJbWdTdHlsZSkge1xuICAgICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0uc2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LW9yaWdpbmFsLXN0eWxlcycsIGN1ckltZ1N0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbiBhbmQgei1pbmRleCB0byB0aGUgcGFyZW50XG4gICAgaWYgKHNlbGYuY3NzKHNlbGYuJGl0ZW0sICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwge1xuICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmNzcyhzZWxmLiRpdGVtLCAnei1pbmRleCcpID09PSAnYXV0bycpIHtcbiAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgekluZGV4OiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjb250YWluZXIgZm9yIHBhcmFsbGF4IGltYWdlXG4gICAgc2VsZi5pbWFnZS4kY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kY29udGFpbmVyLCBjb250YWluZXJTdHlsZXMpO1xuICAgIHNlbGYuY3NzKHNlbGYuaW1hZ2UuJGNvbnRhaW5lciwge1xuICAgICAgJ3otaW5kZXgnOiBzZWxmLm9wdGlvbnMuekluZGV4XG4gICAgfSk7XG5cbiAgICAvLyBpdCB3aWxsIHJlbW92ZSBzb21lIGltYWdlIG92ZXJsYXBwaW5nXG4gICAgLy8gb3ZlcmxhcHBpbmcgb2NjdXIgZHVlIHRvIGFuIGltYWdlIHBvc2l0aW9uIGZpeGVkIGluc2lkZSBhYnNvbHV0ZSBwb3NpdGlvbiBlbGVtZW50XG4gICAgLy8gbmVlZGVkIG9ubHkgd2hlbiBiYWNrZ3JvdW5kIGluIGZpeGVkIHBvc2l0aW9uXG4gICAgaWYgKHRoaXMuaW1hZ2UucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHNlbGYuY3NzKHNlbGYuaW1hZ2UuJGNvbnRhaW5lciwge1xuICAgICAgICAnLXdlYmtpdC1jbGlwLXBhdGgnOiAncG9seWdvbigwIDAsIDEwMCUgMCwgMTAwJSAxMDAlLCAwIDEwMCUpJyxcbiAgICAgICAgJ2NsaXAtcGF0aCc6ICdwb2x5Z29uKDAgMCwgMTAwJSAwLCAxMDAlIDEwMCUsIDAgMTAwJSknXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY29udGFpbmVyIHVuaXF1ZSBJRC5cbiAgICBzZWxmLmltYWdlLiRjb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsIGBqYXJhbGxheC1jb250YWluZXItJHtzZWxmLmluc3RhbmNlSUR9YCk7XG5cbiAgICAvLyBBZGQgY29udGFpbmVyIGNsYXNzLlxuICAgIGlmIChzZWxmLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpIHtcbiAgICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgc2VsZi5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcbiAgICB9XG4gICAgc2VsZi4kaXRlbS5hcHBlbmRDaGlsZChzZWxmLmltYWdlLiRjb250YWluZXIpO1xuXG4gICAgLy8gdXNlIGltZyB0YWdcbiAgICBpZiAoc2VsZi5pbWFnZS51c2VJbWdUYWcpIHtcbiAgICAgIGltYWdlU3R5bGVzID0gc2VsZi5leHRlbmQoe1xuICAgICAgICAnb2JqZWN0LWZpdCc6IHNlbGYub3B0aW9ucy5pbWdTaXplLFxuICAgICAgICAnb2JqZWN0LXBvc2l0aW9uJzogc2VsZi5vcHRpb25zLmltZ1Bvc2l0aW9uLFxuICAgICAgICAnbWF4LXdpZHRoJzogJ25vbmUnXG4gICAgICB9LCBjb250YWluZXJTdHlsZXMsIGltYWdlU3R5bGVzKTtcblxuICAgICAgLy8gdXNlIGRpdiB3aXRoIGJhY2tncm91bmQgaW1hZ2VcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5pbWFnZS4kaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaWYgKHNlbGYuaW1hZ2Uuc3JjKSB7XG4gICAgICAgIGltYWdlU3R5bGVzID0gc2VsZi5leHRlbmQoe1xuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uJzogc2VsZi5vcHRpb25zLmltZ1Bvc2l0aW9uLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXNpemUnOiBzZWxmLm9wdGlvbnMuaW1nU2l6ZSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiBzZWxmLm9wdGlvbnMuaW1nUmVwZWF0LFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWltYWdlJzogc2VsZi5pbWFnZS5iZ0ltYWdlIHx8IGB1cmwoXCIke3NlbGYuaW1hZ2Uuc3JjfVwiKWBcbiAgICAgICAgfSwgY29udGFpbmVyU3R5bGVzLCBpbWFnZVN0eWxlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ29wYWNpdHknIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUnIHx8IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2NhbGUtb3BhY2l0eScgfHwgc2VsZi5vcHRpb25zLnNwZWVkID09PSAxKSB7XG4gICAgICBzZWxmLmltYWdlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB9XG5cbiAgICAvLyAxLiBDaGVjayBpZiBvbmUgb2YgcGFyZW50cyBoYXZlIHRyYW5zZm9ybSBzdHlsZSAod2l0aG91dCB0aGlzIGNoZWNrLCBzY3JvbGwgdHJhbnNmb3JtIHdpbGwgYmUgaW52ZXJ0ZWQgaWYgdXNlZCBwYXJhbGxheCB3aXRoIHBvc2l0aW9uIGZpeGVkKVxuICAgIC8vICAgIGRpc2N1c3Npb24gLSBodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9pc3N1ZXMvOVxuICAgIC8vIDIuIENoZWNrIGlmIHBhcmVudHMgaGF2ZSBvdmVyZmxvdyBzY3JvbGxcbiAgICBpZiAoc2VsZi5pbWFnZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgY29uc3QgJHBhcmVudHMgPSBnZXRQYXJlbnRzKHNlbGYuJGl0ZW0pLmZpbHRlcihlbCA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGdsb2JhbCQyLmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICBjb25zdCBwYXJlbnRUcmFuc2Zvcm0gPSBzdHlsZXNbJy13ZWJraXQtdHJhbnNmb3JtJ10gfHwgc3R5bGVzWyctbW96LXRyYW5zZm9ybSddIHx8IHN0eWxlcy50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IG92ZXJmbG93UmVnZXggPSAvKGF1dG98c2Nyb2xsKS87XG4gICAgICAgIHJldHVybiBwYXJlbnRUcmFuc2Zvcm0gJiYgcGFyZW50VHJhbnNmb3JtICE9PSAnbm9uZScgfHwgb3ZlcmZsb3dSZWdleC50ZXN0KHN0eWxlcy5vdmVyZmxvdyArIHN0eWxlc1snb3ZlcmZsb3cteSddICsgc3R5bGVzWydvdmVyZmxvdy14J10pO1xuICAgICAgfSk7XG4gICAgICBzZWxmLmltYWdlLnBvc2l0aW9uID0gJHBhcmVudHMubGVuZ3RoID8gJ2Fic29sdXRlJyA6ICdmaXhlZCc7XG4gICAgfVxuXG4gICAgLy8gYWRkIHBvc2l0aW9uIHRvIHBhcmFsbGF4IGJsb2NrXG4gICAgaW1hZ2VTdHlsZXMucG9zaXRpb24gPSBzZWxmLmltYWdlLnBvc2l0aW9uO1xuXG4gICAgLy8gaW5zZXJ0IHBhcmFsbGF4IGltYWdlXG4gICAgc2VsZi5jc3Moc2VsZi5pbWFnZS4kaXRlbSwgaW1hZ2VTdHlsZXMpO1xuICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxmLmltYWdlLiRpdGVtKTtcblxuICAgIC8vIHNldCBpbml0aWFsIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgc2VsZi5vblJlc2l6ZSgpO1xuICAgIHNlbGYub25TY3JvbGwodHJ1ZSk7XG5cbiAgICAvLyBjYWxsIG9uSW5pdCBldmVudFxuICAgIGlmIChzZWxmLm9wdGlvbnMub25Jbml0KSB7XG4gICAgICBzZWxmLm9wdGlvbnMub25Jbml0LmNhbGwoc2VsZik7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGRlZmF1bHQgdXNlciBiYWNrZ3JvdW5kXG4gICAgaWYgKHNlbGYuY3NzKHNlbGYuJGl0ZW0sICdiYWNrZ3JvdW5kLWltYWdlJykgIT09ICdub25lJykge1xuICAgICAgc2VsZi5jc3Moc2VsZi4kaXRlbSwge1xuICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGFkZE9ic2VydmVyKHNlbGYpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmVtb3ZlT2JzZXJ2ZXIoc2VsZik7XG5cbiAgICAvLyByZXR1cm4gc3R5bGVzIG9uIGNvbnRhaW5lciBhcyBiZWZvcmUgamFyYWxsYXggaW5pdFxuICAgIGNvbnN0IG9yaWdpbmFsU3R5bGVzVGFnID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgc2VsZi4kaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgLy8gbnVsbCBvY2N1cnMgaWYgdGhlcmUgaXMgbm8gc3R5bGUgdGFnIGJlZm9yZSBqYXJhbGxheCBpbml0XG4gICAgaWYgKCFvcmlnaW5hbFN0eWxlc1RhZykge1xuICAgICAgc2VsZi4kaXRlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuJGl0ZW0uc2V0QXR0cmlidXRlKCdzdHlsZScsIG9yaWdpbmFsU3R5bGVzVGFnKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuaW1hZ2UudXNlSW1nVGFnKSB7XG4gICAgICAvLyByZXR1cm4gc3R5bGVzIG9uIGltZyB0YWcgYXMgYmVmb3JlIGphcmFsbGF4IGluaXRcbiAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGVzSW1nVGFnID0gc2VsZi5pbWFnZS4kaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJyk7XG4gICAgICBzZWxmLmltYWdlLiRpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnKTtcbiAgICAgIC8vIG51bGwgb2NjdXJzIGlmIHRoZXJlIGlzIG5vIHN0eWxlIHRhZyBiZWZvcmUgamFyYWxsYXggaW5pdFxuICAgICAgaWYgKCFvcmlnaW5hbFN0eWxlc0ltZ1RhZykge1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0uc2V0QXR0cmlidXRlKCdzdHlsZScsIG9yaWdpbmFsU3R5bGVzVGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbW92ZSBpbWcgdGFnIHRvIGl0cyBkZWZhdWx0IHBvc2l0aW9uXG4gICAgICBpZiAoc2VsZi5pbWFnZS4kaXRlbVBhcmVudCkge1xuICAgICAgICBzZWxmLmltYWdlLiRpdGVtUGFyZW50LmFwcGVuZENoaWxkKHNlbGYuaW1hZ2UuJGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBhZGRpdGlvbmFsIGRvbSBlbGVtZW50c1xuICAgIGlmIChzZWxmLmltYWdlLiRjb250YWluZXIpIHtcbiAgICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbGYuaW1hZ2UuJGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBvbkRlc3Ryb3kgZXZlbnRcbiAgICBpZiAoc2VsZi5vcHRpb25zLm9uRGVzdHJveSkge1xuICAgICAgc2VsZi5vcHRpb25zLm9uRGVzdHJveS5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIC8vIGRlbGV0ZSBqYXJhbGxheCBmcm9tIGl0ZW1cbiAgICBkZWxldGUgc2VsZi4kaXRlbS5qYXJhbGxheDtcbiAgfVxuICBjb3ZlckltYWdlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIGhlaWdodDogd25kSFxuICAgIH0gPSBnZXRXaW5kb3dTaXplKCk7XG4gICAgY29uc3QgcmVjdCA9IHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250SCA9IHJlY3QuaGVpZ2h0O1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWVkXG4gICAgfSA9IHNlbGYub3B0aW9ucztcbiAgICBjb25zdCBpc1Njcm9sbCA9IHNlbGYub3B0aW9ucy50eXBlID09PSAnc2Nyb2xsJyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbC1vcGFjaXR5JztcbiAgICBsZXQgc2Nyb2xsRGlzdCA9IDA7XG4gICAgbGV0IHJlc3VsdEggPSBjb250SDtcbiAgICBsZXQgcmVzdWx0TVQgPSAwO1xuXG4gICAgLy8gc2Nyb2xsIHBhcmFsbGF4XG4gICAgaWYgKGlzU2Nyb2xsKSB7XG4gICAgICAvLyBzY3JvbGwgZGlzdGFuY2UgYW5kIGhlaWdodCBmb3IgaW1hZ2VcbiAgICAgIGlmIChzcGVlZCA8IDApIHtcbiAgICAgICAgc2Nyb2xsRGlzdCA9IHNwZWVkICogTWF0aC5tYXgoY29udEgsIHduZEgpO1xuICAgICAgICBpZiAod25kSCA8IGNvbnRIKSB7XG4gICAgICAgICAgc2Nyb2xsRGlzdCAtPSBzcGVlZCAqIChjb250SCAtIHduZEgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY3JvbGxEaXN0ID0gc3BlZWQgKiAoY29udEggKyB3bmRIKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2l6ZSBmb3Igc2Nyb2xsIHBhcmFsbGF4XG4gICAgICBpZiAoc3BlZWQgPiAxKSB7XG4gICAgICAgIHJlc3VsdEggPSBNYXRoLmFicyhzY3JvbGxEaXN0IC0gd25kSCk7XG4gICAgICB9IGVsc2UgaWYgKHNwZWVkIDwgMCkge1xuICAgICAgICByZXN1bHRIID0gc2Nyb2xsRGlzdCAvIHNwZWVkICsgTWF0aC5hYnMoc2Nyb2xsRGlzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRIICs9ICh3bmRIIC0gY29udEgpICogKDEgLSBzcGVlZCk7XG4gICAgICB9XG4gICAgICBzY3JvbGxEaXN0IC89IDI7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgc2Nyb2xsIGRpc3RhbmNlXG4gICAgc2VsZi5wYXJhbGxheFNjcm9sbERpc3RhbmNlID0gc2Nyb2xsRGlzdDtcblxuICAgIC8vIHZlcnRpY2FsIGNlbnRlclxuICAgIGlmIChpc1Njcm9sbCkge1xuICAgICAgcmVzdWx0TVQgPSAod25kSCAtIHJlc3VsdEgpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0TVQgPSAoY29udEggLSByZXN1bHRIKSAvIDI7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgcmVzdWx0IHRvIGl0ZW1cbiAgICBzZWxmLmNzcyhzZWxmLmltYWdlLiRpdGVtLCB7XG4gICAgICBoZWlnaHQ6IGAke3Jlc3VsdEh9cHhgLFxuICAgICAgbWFyZ2luVG9wOiBgJHtyZXN1bHRNVH1weGAsXG4gICAgICBsZWZ0OiBzZWxmLmltYWdlLnBvc2l0aW9uID09PSAnZml4ZWQnID8gYCR7cmVjdC5sZWZ0fXB4YCA6ICcwJyxcbiAgICAgIHdpZHRoOiBgJHtyZWN0LndpZHRofXB4YFxuICAgIH0pO1xuXG4gICAgLy8gY2FsbCBvbkNvdmVySW1hZ2UgZXZlbnRcbiAgICBpZiAoc2VsZi5vcHRpb25zLm9uQ292ZXJJbWFnZSkge1xuICAgICAgc2VsZi5vcHRpb25zLm9uQ292ZXJJbWFnZS5jYWxsKHNlbGYpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBzb21lIHVzZWZ1bCBkYXRhLiBVc2VkIGluIHRoZSB2aWRlbyBjb3ZlciBmdW5jdGlvblxuICAgIHJldHVybiB7XG4gICAgICBpbWFnZToge1xuICAgICAgICBoZWlnaHQ6IHJlc3VsdEgsXG4gICAgICAgIG1hcmdpblRvcDogcmVzdWx0TVRcbiAgICAgIH0sXG4gICAgICBjb250YWluZXI6IHJlY3RcbiAgICB9O1xuICB9XG4gIGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VsZW1lbnRJblZpZXdwb3J0IHx8IGZhbHNlO1xuICB9XG4gIG9uU2Nyb2xsKGZvcmNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBzdG9wIGNhbGN1bGF0aW9ucyBpZiBpdGVtIGlzIG5vdCBpbiB2aWV3cG9ydFxuICAgIGlmICghZm9yY2UgJiYgIXNlbGYuaXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaGVpZ2h0OiB3bmRIXG4gICAgfSA9IGdldFdpbmRvd1NpemUoKTtcbiAgICBjb25zdCByZWN0ID0gc2VsZi4kaXRlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250VCA9IHJlY3QudG9wO1xuICAgIGNvbnN0IGNvbnRIID0gcmVjdC5oZWlnaHQ7XG4gICAgY29uc3Qgc3R5bGVzID0ge307XG5cbiAgICAvLyBjYWxjdWxhdGUgcGFyYWxsYXggaGVscGluZyB2YXJpYWJsZXNcbiAgICBjb25zdCBiZWZvcmVUb3AgPSBNYXRoLm1heCgwLCBjb250VCk7XG4gICAgY29uc3QgYmVmb3JlVG9wRW5kID0gTWF0aC5tYXgoMCwgY29udEggKyBjb250VCk7XG4gICAgY29uc3QgYWZ0ZXJUb3AgPSBNYXRoLm1heCgwLCAtY29udFQpO1xuICAgIGNvbnN0IGJlZm9yZUJvdHRvbSA9IE1hdGgubWF4KDAsIGNvbnRUICsgY29udEggLSB3bmRIKTtcbiAgICBjb25zdCBiZWZvcmVCb3R0b21FbmQgPSBNYXRoLm1heCgwLCBjb250SCAtIChjb250VCArIGNvbnRIIC0gd25kSCkpO1xuICAgIGNvbnN0IGFmdGVyQm90dG9tID0gTWF0aC5tYXgoMCwgLWNvbnRUICsgd25kSCAtIGNvbnRIKTtcbiAgICBjb25zdCBmcm9tVmlld3BvcnRDZW50ZXIgPSAxIC0gMiAqICgod25kSCAtIGNvbnRUKSAvICh3bmRIICsgY29udEgpKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBvbiBob3cgcGVyY2VudCBvZiBzZWN0aW9uIGlzIHZpc2libGVcbiAgICBsZXQgdmlzaWJsZVBlcmNlbnQgPSAxO1xuICAgIGlmIChjb250SCA8IHduZEgpIHtcbiAgICAgIHZpc2libGVQZXJjZW50ID0gMSAtIChhZnRlclRvcCB8fCBiZWZvcmVCb3R0b20pIC8gY29udEg7XG4gICAgfSBlbHNlIGlmIChiZWZvcmVUb3BFbmQgPD0gd25kSCkge1xuICAgICAgdmlzaWJsZVBlcmNlbnQgPSBiZWZvcmVUb3BFbmQgLyB3bmRIO1xuICAgIH0gZWxzZSBpZiAoYmVmb3JlQm90dG9tRW5kIDw9IHduZEgpIHtcbiAgICAgIHZpc2libGVQZXJjZW50ID0gYmVmb3JlQm90dG9tRW5kIC8gd25kSDtcbiAgICB9XG5cbiAgICAvLyBvcGFjaXR5XG4gICAgaWYgKHNlbGYub3B0aW9ucy50eXBlID09PSAnb3BhY2l0eScgfHwgc2VsZi5vcHRpb25zLnR5cGUgPT09ICdzY2FsZS1vcGFjaXR5JyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbC1vcGFjaXR5Jykge1xuICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCknO1xuICAgICAgc3R5bGVzLm9wYWNpdHkgPSB2aXNpYmxlUGVyY2VudDtcbiAgICB9XG5cbiAgICAvLyBzY2FsZVxuICAgIGlmIChzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3NjYWxlJyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3NjYWxlLW9wYWNpdHknKSB7XG4gICAgICBsZXQgc2NhbGUgPSAxO1xuICAgICAgaWYgKHNlbGYub3B0aW9ucy5zcGVlZCA8IDApIHtcbiAgICAgICAgc2NhbGUgLT0gc2VsZi5vcHRpb25zLnNwZWVkICogdmlzaWJsZVBlcmNlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSArPSBzZWxmLm9wdGlvbnMuc3BlZWQgKiAoMSAtIHZpc2libGVQZXJjZW50KTtcbiAgICAgIH1cbiAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzY2FsZX0pIHRyYW5zbGF0ZTNkKDAsMCwwKWA7XG4gICAgfVxuXG4gICAgLy8gc2Nyb2xsXG4gICAgaWYgKHNlbGYub3B0aW9ucy50eXBlID09PSAnc2Nyb2xsJyB8fCBzZWxmLm9wdGlvbnMudHlwZSA9PT0gJ3Njcm9sbC1vcGFjaXR5Jykge1xuICAgICAgbGV0IHBvc2l0aW9uWSA9IHNlbGYucGFyYWxsYXhTY3JvbGxEaXN0YW5jZSAqIGZyb21WaWV3cG9ydENlbnRlcjtcblxuICAgICAgLy8gZml4IGlmIHBhcmFsbGF4IGJsb2NrIGluIGFic29sdXRlIHBvc2l0aW9uXG4gICAgICBpZiAoc2VsZi5pbWFnZS5wb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBwb3NpdGlvblkgLT0gY29udFQ7XG4gICAgICB9XG4gICAgICBzdHlsZXMudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKDAsJHtwb3NpdGlvbll9cHgsMClgO1xuICAgIH1cbiAgICBzZWxmLmNzcyhzZWxmLmltYWdlLiRpdGVtLCBzdHlsZXMpO1xuXG4gICAgLy8gY2FsbCBvblNjcm9sbCBldmVudFxuICAgIGlmIChzZWxmLm9wdGlvbnMub25TY3JvbGwpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5vblNjcm9sbC5jYWxsKHNlbGYsIHtcbiAgICAgICAgc2VjdGlvbjogcmVjdCxcbiAgICAgICAgYmVmb3JlVG9wLFxuICAgICAgICBiZWZvcmVUb3BFbmQsXG4gICAgICAgIGFmdGVyVG9wLFxuICAgICAgICBiZWZvcmVCb3R0b20sXG4gICAgICAgIGJlZm9yZUJvdHRvbUVuZCxcbiAgICAgICAgYWZ0ZXJCb3R0b20sXG4gICAgICAgIHZpc2libGVQZXJjZW50LFxuICAgICAgICBmcm9tVmlld3BvcnRDZW50ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvblJlc2l6ZSgpIHtcbiAgICB0aGlzLmNvdmVySW1hZ2UoKTtcbiAgfVxufVxuXG4vLyBnbG9iYWwgZGVmaW5pdGlvblxuY29uc3QgamFyYWxsYXgkMSA9IGZ1bmN0aW9uIChpdGVtcywgb3B0aW9ucywgLi4uYXJncykge1xuICAvLyBjaGVjayBmb3IgZG9tIGVsZW1lbnRcbiAgLy8gdGhhbmtzOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM4NDI4Ni9qYXZhc2NyaXB0LWlzZG9tLWhvdy1kby15b3UtY2hlY2staWYtYS1qYXZhc2NyaXB0LW9iamVjdC1pcy1hLWRvbS1vYmplY3RcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ29iamVjdCcgPyBpdGVtcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogaXRlbXMgJiYgdHlwZW9mIGl0ZW1zID09PSAnb2JqZWN0JyAmJiBpdGVtcyAhPT0gbnVsbCAmJiBpdGVtcy5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2YgaXRlbXMubm9kZU5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbXMgPSBbaXRlbXNdO1xuICB9XG4gIGNvbnN0IGxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgbGV0IGsgPSAwO1xuICBsZXQgcmV0O1xuICBmb3IgKGs7IGsgPCBsZW47IGsgKz0gMSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoIWl0ZW1zW2tdLmphcmFsbGF4KSB7XG4gICAgICAgIGl0ZW1zW2tdLmphcmFsbGF4ID0gbmV3IEphcmFsbGF4KGl0ZW1zW2tdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGl0ZW1zW2tdLmphcmFsbGF4KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgcmV0ID0gaXRlbXNba10uamFyYWxsYXhbb3B0aW9uc10uYXBwbHkoaXRlbXNba10uamFyYWxsYXgsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn07XG5qYXJhbGxheCQxLmNvbnN0cnVjdG9yID0gSmFyYWxsYXg7XG5cbi8qIVxuICogVmlkZW8gV29ya2VyIHYyLjIuMCAoaHR0cHM6Ly9naXRodWIuY29tL25rLW8vdmlkZW8td29ya2VyKVxuICogQ29weXJpZ2h0IDIwMjQgbksgPGh0dHBzOi8vbmtkZXYuaW5mbz5cbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25rLW8vdmlkZW8td29ya2VyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXG4gKi9cblxudmFyIGRlZmF1bHRzID0ge1xuICBhdXRvcGxheTogZmFsc2UsXG4gIGxvb3A6IGZhbHNlLFxuICBtdXRlOiBmYWxzZSxcbiAgdm9sdW1lOiAxMDAsXG4gIHNob3dDb250cm9sczogdHJ1ZSxcbiAgYWNjZXNzaWJpbGl0eUhpZGRlbjogZmFsc2UsXG4gIC8vIHN0YXJ0IC8gZW5kIHZpZGVvIHRpbWUgaW4gc2Vjb25kc1xuICBzdGFydFRpbWU6IDAsXG4gIGVuZFRpbWU6IDBcbn07XG5cbi8qKlxuICogRXh0ZW5kIGxpa2UgalF1ZXJ5LmV4dGVuZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvdXQgLSBvdXRwdXQgb2JqZWN0LlxuICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgLSBhZGRpdGlvbmFsIG9iamVjdHMgdG8gZXh0ZW5kLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChvdXQsIC4uLmFyZ3MpIHtcbiAgb3V0ID0gb3V0IHx8IHt9O1xuICBPYmplY3Qua2V5cyhhcmdzKS5mb3JFYWNoKGkgPT4ge1xuICAgIGlmICghYXJnc1tpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhhcmdzW2ldKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBvdXRba2V5XSA9IGFyZ3NbaV1ba2V5XTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvdXQ7XG59XG5sZXQgSUQgPSAwO1xuY2xhc3MgVmlkZW9Xb3JrZXJCYXNlIHtcbiAgdHlwZSA9ICdub25lJztcbiAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi51cmwgPSB1cmw7XG4gICAgc2VsZi5vcHRpb25zX2RlZmF1bHQgPSB7XG4gICAgICAuLi5kZWZhdWx0c1xuICAgIH07XG4gICAgc2VsZi5vcHRpb25zID0gZXh0ZW5kKHt9LCBzZWxmLm9wdGlvbnNfZGVmYXVsdCwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBVUkxcbiAgICBzZWxmLnZpZGVvSUQgPSBzZWxmLmNvbnN0cnVjdG9yLnBhcnNlVVJMKHVybCk7XG5cbiAgICAvLyBpbml0XG4gICAgaWYgKHNlbGYudmlkZW9JRCkge1xuICAgICAgc2VsZi5pbml0KCk7XG4gICAgfVxuICB9XG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy52aWRlb0lEO1xuICB9XG4gIGluaXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5JRCA9IElEO1xuICAgIElEICs9IDE7XG4gICAgc2VsZi5wbGF5ZXJJRCA9IGBWaWRlb1dvcmtlci0ke3NlbGYuSUR9YDtcbiAgfVxuXG4gIC8vIGV2ZW50c1xuICBvbihuYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMudXNlckV2ZW50c0xpc3QgPSB0aGlzLnVzZXJFdmVudHNMaXN0IHx8IFtdO1xuXG4gICAgLy8gYWRkIG5ldyBjYWxsYmFjayBpbiBldmVudHMgbGlzdFxuICAgICh0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdIHx8ICh0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuICBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMudXNlckV2ZW50c0xpc3QgfHwgIXRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgZGVsZXRlIHRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXNlckV2ZW50c0xpc3RbbmFtZV0uZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHZhbCA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdW2tleV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZpcmUobmFtZSwgLi4uYXJncykge1xuICAgIGlmICh0aGlzLnVzZXJFdmVudHNMaXN0ICYmIHR5cGVvZiB0aGlzLnVzZXJFdmVudHNMaXN0W25hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy51c2VyRXZlbnRzTGlzdFtuYW1lXS5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAgIC8vIGNhbGwgd2l0aCBhbGwgYXJndW1lbnRzXG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICB2YWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2RzIHVzZWQgaW4gcHJvdmlkZXJzLlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgc3RhdGljIHBhcnNlVVJMKHVybCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwbGF5KHN0YXJ0KSB7fVxuICBwYXVzZSgpIHt9XG4gIG11dGUoKSB7fVxuICB1bm11dGUoKSB7fVxuICBzZXRWb2x1bWUodm9sdW1lID0gZmFsc2UpIHt9XG4gIGdldFZvbHVtZShjYWxsYmFjaykge31cbiAgZ2V0TXV0ZWQoY2FsbGJhY2spIHt9XG4gIHNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lID0gZmFsc2UpIHt9XG4gIGdldEN1cnJlbnRUaW1lKGNhbGxiYWNrKSB7fVxuICBnZXRJbWFnZVVSTChjYWxsYmFjaykge31cbiAgZ2V0VmlkZW8oY2FsbGJhY2spIHt9XG4gIC8qIGVzbGludC1lbmFibGUgKi9cbn1cblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzICovXG5sZXQgd2luO1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbiA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gIHdpbiA9IHt9O1xufVxudmFyIGdsb2JhbCQxID0gd2luO1xuXG4vLyBEZWZlcnJlZFxuLy8gdGhhbmtzIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgwOTY3MTUvaW1wbGVtZW50LWRlZmVycmVkLW9iamVjdC13aXRob3V0LXVzaW5nLWpxdWVyeVxuZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG4gIHRoaXMuZG9uZUNhbGxiYWNrcyA9IFtdO1xuICB0aGlzLmZhaWxDYWxsYmFja3MgPSBbXTtcbn1cbkRlZmVycmVkLnByb3RvdHlwZSA9IHtcbiAgZXhlY3V0ZShsaXN0LCBhcmdzKSB7XG4gICAgbGV0IGkgPSBsaXN0Lmxlbmd0aDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgd2hpbGUgKGkpIHtcbiAgICAgIGkgLT0gMTtcbiAgICAgIGxpc3RbaV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICB9LFxuICByZXNvbHZlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLmV4ZWN1dGUodGhpcy5kb25lQ2FsbGJhY2tzLCBhcmdzKTtcbiAgfSxcbiAgcmVqZWN0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLmV4ZWN1dGUodGhpcy5mYWlsQ2FsbGJhY2tzLCBhcmdzKTtcbiAgfSxcbiAgZG9uZShjYWxsYmFjaykge1xuICAgIHRoaXMuZG9uZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSxcbiAgZmFpbChjYWxsYmFjaykge1xuICAgIHRoaXMuZmFpbENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxufTtcbmxldCBZb3V0dWJlQVBJYWRkZWQgPSAwO1xubGV0IGxvYWRpbmdZb3V0dWJlUGxheWVyID0gMDtcbmNvbnN0IGxvYWRpbmdZb3V0dWJlRGVmZXIgPSAvKiNfX1BVUkVfXyovbmV3IERlZmVycmVkKCk7XG5mdW5jdGlvbiBsb2FkQVBJJDEoKSB7XG4gIGlmIChZb3V0dWJlQVBJYWRkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgWW91dHViZUFQSWFkZGVkID0gdHJ1ZTtcbiAgY29uc3Qgc3JjID0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2lmcmFtZV9hcGknO1xuXG4gIC8vIGFkZCBzY3JpcHQgaW4gaGVhZCBzZWN0aW9uXG4gIGxldCB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgbGV0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB0YWcuc3JjID0gc3JjO1xuICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gIGhlYWQgPSBudWxsO1xuICB0YWcgPSBudWxsO1xufVxuZnVuY3Rpb24gb25BUElyZWFkeSQxKGNhbGxiYWNrKSB7XG4gIC8vIExpc3RlbiBmb3IgZ2xvYmFsIFlUIHBsYXllciBjYWxsYmFja1xuICBpZiAoKHR5cGVvZiBnbG9iYWwkMS5ZVCA9PT0gJ3VuZGVmaW5lZCcgfHwgZ2xvYmFsJDEuWVQubG9hZGVkID09PSAwKSAmJiAhbG9hZGluZ1lvdXR1YmVQbGF5ZXIpIHtcbiAgICAvLyBQcmV2ZW50cyBSZWFkeSBldmVudCBmcm9tIGJlaW5nIGNhbGxlZCB0d2ljZVxuICAgIGxvYWRpbmdZb3V0dWJlUGxheWVyID0gMTtcblxuICAgIC8vIENyZWF0ZXMgZGVmZXJyZWQgc28sIG90aGVyIHBsYXllcnMga25vdyB3aGVuIHRvIHdhaXQuXG4gICAgZ2xvYmFsJDEub25Zb3VUdWJlSWZyYW1lQVBJUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnbG9iYWwkMS5vbllvdVR1YmVJZnJhbWVBUElSZWFkeSA9IG51bGw7XG4gICAgICBsb2FkaW5nWW91dHViZURlZmVyLnJlc29sdmUoJ2RvbmUnKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsJDEuWVQgPT09ICdvYmplY3QnICYmIGdsb2JhbCQxLllULmxvYWRlZCA9PT0gMSkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgbG9hZGluZ1lvdXR1YmVEZWZlci5kb25lKCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFZpZGVvV29ya2VyWW91dHViZSBleHRlbmRzIFZpZGVvV29ya2VyQmFzZSB7XG4gIHR5cGUgPSAneW91dHViZSc7XG4gIHN0YXRpYyBwYXJzZVVSTCh1cmwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICBjb25zdCByZWdFeHAgPSAvLiooPzp5b3V0dS5iZVxcL3x2XFwvfHVcXC9cXHdcXC98ZW1iZWRcXC98c2hvcnRzXFwvfHdhdGNoXFw/dj0pKFteI1xcJlxcP10qKS4qLztcbiAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdFeHApO1xuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXS5sZW5ndGggPT09IDExID8gbWF0Y2hbMV0gOiBmYWxzZTtcbiAgfVxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcbiAgICBsb2FkQVBJJDEoKTtcbiAgfVxuICBwbGF5KHN0YXJ0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIucGxheVZpZGVvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZWxmLnBsYXllci5zZWVrVG8oc3RhcnQgfHwgMCk7XG4gICAgfVxuICAgIGlmIChnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HICE9PSBzZWxmLnBsYXllci5nZXRQbGF5ZXJTdGF0ZSgpKSB7XG4gICAgICAvLyBEb24ndCBwbGF5IGlmIHZpZGVvIGlzIGFscmVhZHkgZW5kZWQgYW5kIHdpdGggbm8gbG9vcC5cbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSAmJiAhc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgc2VsZi5nZXRDdXJyZW50VGltZShzZWNvbmRzID0+IHtcbiAgICAgICAgICBpZiAoc2Vjb25kcyA8IHNlbGYub3B0aW9ucy5lbmRUaW1lKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXllci5wbGF5VmlkZW8oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5wbGF5ZXIucGxheVZpZGVvKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgIXNlbGYucGxheWVyLnBhdXNlVmlkZW8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGdsb2JhbCQxLllULlBsYXllclN0YXRlLlBMQVlJTkcgPT09IHNlbGYucGxheWVyLmdldFBsYXllclN0YXRlKCkpIHtcbiAgICAgIHNlbGYucGxheWVyLnBhdXNlVmlkZW8oKTtcbiAgICB9XG4gIH1cbiAgbXV0ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8ICFzZWxmLnBsYXllci5tdXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYucGxheWVyLm11dGUoKTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIudW5NdXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYucGxheWVyLnVuTXV0ZSgpO1xuICB9XG4gIHNldFZvbHVtZSh2b2x1bWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgdHlwZW9mIHZvbHVtZSAhPT0gJ251bWJlcicgfHwgIXNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5zZXRWb2x1bWUodm9sdW1lKTtcbiAgfVxuICBnZXRWb2x1bWUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLnBsYXllci5nZXRWb2x1bWUpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmdldFZvbHVtZSgpKTtcbiAgICB9XG4gIH1cbiAgZ2V0TXV0ZWQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYucGxheWVyLmlzTXV0ZWQpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmlzTXV0ZWQoKSk7XG4gICAgfVxuICB9XG4gIHNldEN1cnJlbnRUaW1lKGN1cnJlbnRUaW1lID0gZmFsc2UpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8IHR5cGVvZiBjdXJyZW50VGltZSAhPT0gJ251bWJlcicgfHwgIXNlbGYucGxheWVyLnNlZWtUbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5zZWVrVG8oY3VycmVudFRpbWUpO1xuICB9XG4gIGdldEN1cnJlbnRUaW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2soc2VsZi5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKSk7XG4gIH1cbiAgZ2V0SW1hZ2VVUkwoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi52aWRlb0ltYWdlKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVTaXplcyA9IFsnbWF4cmVzZGVmYXVsdCcsICdzZGRlZmF1bHQnLCAnaHFkZWZhdWx0JywgJzAnXTtcbiAgICBsZXQgc3RlcCA9IDA7XG4gICAgY29uc3QgdGVtcEltZyA9IG5ldyBJbWFnZSgpO1xuICAgIHRlbXBJbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gaWYgbm8gdGh1bWJuYWlsLCB5b3V0dWJlIGFkZCB0aGVpciBvd24gaW1hZ2Ugd2l0aCB3aWR0aCA9IDEyMHB4XG4gICAgICBpZiAoKHRoaXMubmF0dXJhbFdpZHRoIHx8IHRoaXMud2lkdGgpICE9PSAxMjAgfHwgc3RlcCA9PT0gYXZhaWxhYmxlU2l6ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBva1xuICAgICAgICBzZWxmLnZpZGVvSW1hZ2UgPSBgaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJHtzZWxmLnZpZGVvSUR9LyR7YXZhaWxhYmxlU2l6ZXNbc3RlcF19LmpwZ2A7XG4gICAgICAgIGNhbGxiYWNrKHNlbGYudmlkZW9JbWFnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0cnkgYW5vdGhlciBzaXplXG4gICAgICAgIHN0ZXAgKz0gMTtcbiAgICAgICAgdGhpcy5zcmMgPSBgaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJHtzZWxmLnZpZGVvSUR9LyR7YXZhaWxhYmxlU2l6ZXNbc3RlcF19LmpwZ2A7XG4gICAgICB9XG4gICAgfTtcbiAgICB0ZW1wSW1nLnNyYyA9IGBodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8ke3NlbGYudmlkZW9JRH0vJHthdmFpbGFibGVTaXplc1tzdGVwXX0uanBnYDtcbiAgfVxuICBnZXRWaWRlbyhjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gcmV0dXJuIGdlbmVyYXRlZCB2aWRlbyBibG9ja1xuICAgIGlmIChzZWxmLiR2aWRlbykge1xuICAgICAgY2FsbGJhY2soc2VsZi4kdmlkZW8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIG5ldyB2aWRlbyBibG9ja1xuICAgIG9uQVBJcmVhZHkkMSgoKSA9PiB7XG4gICAgICBsZXQgaGlkZGVuRGl2O1xuICAgICAgaWYgKCFzZWxmLiR2aWRlbykge1xuICAgICAgICBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgaGlkZGVuRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgICBzZWxmLnBsYXllck9wdGlvbnMgPSB7XG4gICAgICAgIC8vIEdEUFIgQ29tcGxpYW5jZS5cbiAgICAgICAgaG9zdDogJ2h0dHBzOi8vd3d3LnlvdXR1YmUtbm9jb29raWUuY29tJyxcbiAgICAgICAgdmlkZW9JZDogc2VsZi52aWRlb0lELFxuICAgICAgICBwbGF5ZXJWYXJzOiB7XG4gICAgICAgICAgYXV0b2hpZGU6IDEsXG4gICAgICAgICAgcmVsOiAwLFxuICAgICAgICAgIGF1dG9wbGF5OiAwLFxuICAgICAgICAgIC8vIGF1dG9wbGF5IGVuYWJsZSBvbiBtb2JpbGUgZGV2aWNlc1xuICAgICAgICAgIHBsYXlzaW5saW5lOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGhpZGUgY29udHJvbHNcbiAgICAgIGlmICghc2VsZi5vcHRpb25zLnNob3dDb250cm9scykge1xuICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5pdl9sb2FkX3BvbGljeSA9IDM7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wbGF5ZXJWYXJzLm1vZGVzdGJyYW5kaW5nID0gMTtcbiAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLnBsYXllclZhcnMuY29udHJvbHMgPSAwO1xuICAgICAgICBzZWxmLnBsYXllck9wdGlvbnMucGxheWVyVmFycy5zaG93aW5mbyA9IDA7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5wbGF5ZXJWYXJzLmRpc2FibGVrYiA9IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIGV2ZW50c1xuICAgICAgbGV0IHl0U3RhcnRlZDtcbiAgICAgIGxldCB5dFByb2dyZXNzSW50ZXJ2YWw7XG4gICAgICBzZWxmLnBsYXllck9wdGlvbnMuZXZlbnRzID0ge1xuICAgICAgICBvblJlYWR5KGUpIHtcbiAgICAgICAgICAvLyBtdXRlXG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5tdXRlKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5tdXRlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLnZvbHVtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnNldFZvbHVtZShzZWxmLm9wdGlvbnMudm9sdW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhdXRvcGxheVxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuYXV0b3BsYXkpIHtcbiAgICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5maXJlKCdyZWFkeScsIGUpO1xuXG4gICAgICAgICAgLy8gRm9yIHNlYW1sZXNzIGxvb3BzLCBzZXQgdGhlIGVuZFRpbWUgdG8gMC4xIHNlY29uZHMgbGVzcyB0aGFuIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25rLW8vdmlkZW8td29ya2VyL2lzc3Vlcy8yXG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5sb29wICYmICFzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kc09mZnNldCA9IDAuMTtcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5lbmRUaW1lID0gc2VsZi5wbGF5ZXIuZ2V0RHVyYXRpb24oKSAtIHNlY29uZHNPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdm9sdW1lY2hhbmdlXG4gICAgICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgc2VsZi5nZXRWb2x1bWUodm9sdW1lID0+IHtcbiAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy52b2x1bWUgIT09IHZvbHVtZSkge1xuICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy52b2x1bWUgPSB2b2x1bWU7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlKCd2b2x1bWVjaGFuZ2UnLCBlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdGF0ZUNoYW5nZShlKSB7XG4gICAgICAgICAgLy8gbG9vcFxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCAmJiBlLmRhdGEgPT09IGdsb2JhbCQxLllULlBsYXllclN0YXRlLkVOREVEKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXkoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgheXRTdGFydGVkICYmIGUuZGF0YSA9PT0gZ2xvYmFsJDEuWVQuUGxheWVyU3RhdGUuUExBWUlORykge1xuICAgICAgICAgICAgeXRTdGFydGVkID0gMTtcbiAgICAgICAgICAgIHNlbGYuZmlyZSgnc3RhcnRlZCcsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5kYXRhID09PSBnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICAgICAgICBzZWxmLmZpcmUoJ3BsYXknLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUuZGF0YSA9PT0gZ2xvYmFsJDEuWVQuUGxheWVyU3RhdGUuUEFVU0VEKSB7XG4gICAgICAgICAgICBzZWxmLmZpcmUoJ3BhdXNlJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlLmRhdGEgPT09IGdsb2JhbCQxLllULlBsYXllclN0YXRlLkVOREVEKSB7XG4gICAgICAgICAgICBzZWxmLmZpcmUoJ2VuZGVkJywgZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcHJvZ3Jlc3MgY2hlY2tcbiAgICAgICAgICBpZiAoZS5kYXRhID09PSBnbG9iYWwkMS5ZVC5QbGF5ZXJTdGF0ZS5QTEFZSU5HKSB7XG4gICAgICAgICAgICB5dFByb2dyZXNzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgIHNlbGYuZmlyZSgndGltZXVwZGF0ZScsIGUpO1xuXG4gICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlbmQgb2YgdmlkZW8gYW5kIHBsYXkgYWdhaW4gb3Igc3RvcFxuICAgICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmVuZFRpbWUgJiYgc2VsZi5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKSA+PSBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICAgICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxNTApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHl0UHJvZ3Jlc3NJbnRlcnZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yKGUpIHtcbiAgICAgICAgICBzZWxmLmZpcmUoJ2Vycm9yJywgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBmaXJzdEluaXQgPSAhc2VsZi4kdmlkZW87XG4gICAgICBpZiAoZmlyc3RJbml0KSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdpZCcsIHNlbGYucGxheWVySUQpO1xuICAgICAgICBoaWRkZW5EaXYuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoaWRkZW5EaXYpO1xuICAgICAgfVxuICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLnBsYXllciB8fCBuZXcgZ2xvYmFsJDEuWVQuUGxheWVyKHNlbGYucGxheWVySUQsIHNlbGYucGxheWVyT3B0aW9ucyk7XG4gICAgICBpZiAoZmlyc3RJbml0KSB7XG4gICAgICAgIHNlbGYuJHZpZGVvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc2VsZi5wbGF5ZXJJRCk7XG5cbiAgICAgICAgLy8gYWRkIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmFjY2Vzc2liaWxpdHlIaWRkZW4pIHtcbiAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdmlkZW8gd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBzZWxmLnZpZGVvV2lkdGggPSBwYXJzZUludChzZWxmLiR2aWRlby5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKSB8fCAxMjgwO1xuICAgICAgICBzZWxmLnZpZGVvSGVpZ2h0ID0gcGFyc2VJbnQoc2VsZi4kdmlkZW8uZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSwgMTApIHx8IDcyMDtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgICB9KTtcbiAgfVxufVxubGV0IFZpbWVvQVBJYWRkZWQgPSAwO1xubGV0IGxvYWRpbmdWaW1lb1BsYXllciA9IDA7XG5jb25zdCBsb2FkaW5nVmltZW9EZWZlciA9IC8qI19fUFVSRV9fKi9uZXcgRGVmZXJyZWQoKTtcbmZ1bmN0aW9uIGxvYWRBUEkoKSB7XG4gIGlmIChWaW1lb0FQSWFkZGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFZpbWVvQVBJYWRkZWQgPSB0cnVlO1xuXG4gIC8vIFVzZWZ1bCB3aGVuIFZpbWVvIEFQSSBhZGRlZCB1c2luZyBSZXF1aXJlSlMgaHR0cHM6Ly9naXRodWIuY29tL25rLW8vdmlkZW8td29ya2VyL3B1bGwvN1xuICBpZiAodHlwZW9mIGdsb2JhbCQxLlZpbWVvICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzcmMgPSAnaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL2FwaS9wbGF5ZXIuanMnO1xuXG4gIC8vIGFkZCBzY3JpcHQgaW4gaGVhZCBzZWN0aW9uXG4gIGxldCB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgbGV0IGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB0YWcuc3JjID0gc3JjO1xuICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gIGhlYWQgPSBudWxsO1xuICB0YWcgPSBudWxsO1xufVxuZnVuY3Rpb24gb25BUElyZWFkeShjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGdsb2JhbCQxLlZpbWVvID09PSAndW5kZWZpbmVkJyAmJiAhbG9hZGluZ1ZpbWVvUGxheWVyKSB7XG4gICAgbG9hZGluZ1ZpbWVvUGxheWVyID0gMTtcbiAgICBjb25zdCB2aW1lb0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBnbG9iYWwkMS5WaW1lbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh2aW1lb0ludGVydmFsKTtcbiAgICAgICAgbG9hZGluZ1ZpbWVvRGVmZXIucmVzb2x2ZSgnZG9uZScpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0sIDIwKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsJDEuVmltZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICBsb2FkaW5nVmltZW9EZWZlci5kb25lKCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFZpZGVvV29ya2VyVmltZW8gZXh0ZW5kcyBWaWRlb1dvcmtlckJhc2Uge1xuICB0eXBlID0gJ3ZpbWVvJztcbiAgc3RhdGljIHBhcnNlVVJMKHVybCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgIGNvbnN0IHJlZ0V4cCA9IC9odHRwcz86XFwvXFwvKD86d3d3XFwufHBsYXllclxcLik/dmltZW8uY29tXFwvKD86Y2hhbm5lbHNcXC8oPzpcXHcrXFwvKT98Z3JvdXBzXFwvKFteL10qKVxcL3ZpZGVvc1xcL3xhbGJ1bVxcLyhcXGQrKVxcL3ZpZGVvXFwvfHZpZGVvXFwvfCkoXFxkKykoPzokfFxcL3xcXD8pLztcbiAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaChyZWdFeHApO1xuICAgIHJldHVybiBtYXRjaCAmJiBtYXRjaFszXSA/IG1hdGNoWzNdIDogZmFsc2U7XG4gIH1cblxuICAvLyBUcnkgdG8gZXh0cmFjdCBhIGhhc2ggZm9yIHByaXZhdGUgdmlkZW9zIGZyb20gdGhlIFVSTC5cbiAgLy8gVGhhbmtzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW1wb3R0cy9wbHlyXG4gIHN0YXRpYyBwYXJzZVVSTEhhc2godXJsKSB7XG4gICAgLyogVGhpcyByZWdleCBtYXRjaGVzIGEgaGV4YWRlY2ltYWwgaGFzaCBpZiBnaXZlbiBpbiBhbnkgb2YgdGhlc2UgZm9ybXM6XG4gICAgICogIC0gW2h0dHBzOi8vcGxheWVyLl12aW1lby5jb20vdmlkZW8ve2lkfS97aGFzaH1bP3BhcmFtc11cbiAgICAgKiAgLSBbaHR0cHM6Ly9wbGF5ZXIuXXZpbWVvLmNvbS92aWRlby97aWR9P2g9e2hhc2h9WyZwYXJhbXNdXG4gICAgICogIC0gW2h0dHBzOi8vcGxheWVyLl12aW1lby5jb20vdmlkZW8ve2lkfT9bcGFyYW1zXSZoPXtoYXNofVxuICAgICAqICAtIHZpZGVvL3tpZH0ve2hhc2h9XG4gICAgICogSWYgbWF0Y2hlZCwgdGhlIGhhc2ggaXMgYXZhaWxhYmxlIGluIGNhcHR1cmUgZ3JvdXAgNFxuICAgICAqL1xuICAgIGNvbnN0IHJlZ2V4ID0gL14uKih2aW1lby5jb21cXC98dmlkZW9cXC8pKFxcZCspKFxcPy4qJipoPXxcXC8pKyhbXFxkLGEtZl0rKS87XG4gICAgY29uc3QgZm91bmQgPSB1cmwubWF0Y2gocmVnZXgpO1xuICAgIHJldHVybiBmb3VuZCAmJiBmb3VuZC5sZW5ndGggPT09IDUgPyBmb3VuZFs0XSA6IG51bGw7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgbG9hZEFQSSgpO1xuICB9XG4gIHBsYXkoc3RhcnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZWxmLnBsYXllci5zZXRDdXJyZW50VGltZShzdGFydCk7XG4gICAgfVxuICAgIHNlbGYucGxheWVyLmdldFBhdXNlZCgpLnRoZW4ocGF1c2VkID0+IHtcbiAgICAgIGlmIChwYXVzZWQpIHtcbiAgICAgICAgLy8gRG9uJ3QgcGxheSBpZiB2aWRlbyBpcyBhbHJlYWR5IGVuZGVkIGFuZCB3aXRoIG5vIGxvb3AuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSAmJiAhc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgICBzZWxmLmdldEN1cnJlbnRUaW1lKHNlY29uZHMgPT4ge1xuICAgICAgICAgICAgaWYgKHNlY29uZHMgPCBzZWxmLm9wdGlvbnMuZW5kVGltZSkge1xuICAgICAgICAgICAgICBzZWxmLnBsYXllci5wbGF5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5wbGF5ZXIucGxheSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5nZXRQYXVzZWQoKS50aGVuKHBhdXNlZCA9PiB7XG4gICAgICBpZiAoIXBhdXNlZCkge1xuICAgICAgICBzZWxmLnBsYXllci5wYXVzZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCAhc2VsZi5wbGF5ZXIuc2V0Vm9sdW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuc2V0Vm9sdW1lKDApO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8ICFzZWxmLnBsYXllci5zZXRWb2x1bWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHRoZSBkZWZhdWx0IHZvbHVtZSBpcyAwLCB3ZSBoYXZlIHRvIHNldCAxMDAgd2hlbiB1bm11dGUuXG4gICAgc2VsZi5zZXRWb2x1bWUoc2VsZi5vcHRpb25zLnZvbHVtZSB8fCAxMDApO1xuICB9XG4gIHNldFZvbHVtZSh2b2x1bWUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIgfHwgdHlwZW9mIHZvbHVtZSAhPT0gJ251bWJlcicgfHwgIXNlbGYucGxheWVyLnNldFZvbHVtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5zZXRWb2x1bWUodm9sdW1lIC8gMTAwKTtcbiAgfVxuICBnZXRWb2x1bWUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLnBsYXllci5nZXRWb2x1bWUpIHtcbiAgICAgIHNlbGYucGxheWVyLmdldFZvbHVtZSgpLnRoZW4odm9sdW1lID0+IHtcbiAgICAgICAgY2FsbGJhY2sodm9sdW1lICogMTAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXRNdXRlZChjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2VsZi5wbGF5ZXIuZ2V0Vm9sdW1lKSB7XG4gICAgICBzZWxmLnBsYXllci5nZXRWb2x1bWUoKS50aGVuKHZvbHVtZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCEhdm9sdW1lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzZXRDdXJyZW50VGltZShjdXJyZW50VGltZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCB0eXBlb2YgY3VycmVudFRpbWUgIT09ICdudW1iZXInIHx8ICFzZWxmLnBsYXllci5zZXRDdXJyZW50VGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5zZXRDdXJyZW50VGltZShjdXJyZW50VGltZSk7XG4gIH1cbiAgZ2V0Q3VycmVudFRpbWUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyIHx8ICFzZWxmLnBsYXllci5nZXRDdXJyZW50VGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLnBsYXllci5nZXRDdXJyZW50VGltZSgpLnRoZW4oY3VycmVudFRpbWUgPT4ge1xuICAgICAgY2FsbGJhY2soY3VycmVudFRpbWUpO1xuICAgIH0pO1xuICB9XG4gIGdldEltYWdlVVJMKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHNlbGYudmlkZW9JbWFnZSkge1xuICAgICAgY2FsbGJhY2soc2VsZi52aWRlb0ltYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBzaG91bGQgcHJvdmlkZSB3aWR0aCB0byBnZXQgSFEgdGh1bWJuYWlsIFVSTC5cbiAgICBsZXQgd2lkdGggPSBnbG9iYWwkMS5pbm5lcldpZHRoIHx8IDE5MjA7XG4gICAgaWYgKGdsb2JhbCQxLmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgIHdpZHRoICo9IGdsb2JhbCQxLmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIDE5MjApO1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgLy8gaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP3VybD1odHRwczovL3ZpbWVvLmNvbS8yMzUyMTI1MjdcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIGBodHRwczovL3ZpbWVvLmNvbS9hcGkvb2VtYmVkLmpzb24/dXJsPSR7c2VsZi51cmx9JndpZHRoPSR7d2lkdGh9YCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAvLyBTdWNjZXNzIVxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnRodW1ibmFpbF91cmwpIHtcbiAgICAgICAgICAgIHNlbGYudmlkZW9JbWFnZSA9IHJlc3BvbnNlLnRodW1ibmFpbF91cmw7XG4gICAgICAgICAgICBjYWxsYmFjayhzZWxmLnZpZGVvSW1hZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgcmVxdWVzdCA9IG51bGw7XG4gIH1cbiAgZ2V0VmlkZW8oY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIC8vIHJldHVybiBnZW5lcmF0ZWQgdmlkZW8gYmxvY2tcbiAgICBpZiAoc2VsZi4kdmlkZW8pIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnZW5lcmF0ZSBuZXcgdmlkZW8gYmxvY2tcbiAgICBvbkFQSXJlYWR5KCgpID0+IHtcbiAgICAgIGxldCBoaWRkZW5EaXY7XG4gICAgICBpZiAoIXNlbGYuJHZpZGVvKSB7XG4gICAgICAgIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBoaWRkZW5EaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIHNlbGYucGxheWVyT3B0aW9ucyA9IHtcbiAgICAgICAgLy8gR0RQUiBDb21wbGlhbmNlLlxuICAgICAgICBkbnQ6IDEsXG4gICAgICAgIGlkOiBzZWxmLnZpZGVvSUQsXG4gICAgICAgIGF1dG9wYXVzZTogMCxcbiAgICAgICAgdHJhbnNwYXJlbnQ6IDAsXG4gICAgICAgIGF1dG9wbGF5OiBzZWxmLm9wdGlvbnMuYXV0b3BsYXkgPyAxIDogMCxcbiAgICAgICAgbG9vcDogc2VsZi5vcHRpb25zLmxvb3AgPyAxIDogMCxcbiAgICAgICAgbXV0ZWQ6IHNlbGYub3B0aW9ucy5tdXRlIHx8IHNlbGYub3B0aW9ucy52b2x1bWUgPT09IDAgPyAxIDogMFxuICAgICAgfTtcblxuICAgICAgLy8gcHJpdmF0ZSB2aWRlbyBoYXNoXG4gICAgICBjb25zdCB1cmxIYXNoID0gc2VsZi5jb25zdHJ1Y3Rvci5wYXJzZVVSTEhhc2goc2VsZi51cmwpO1xuICAgICAgaWYgKHVybEhhc2gpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLmggPSB1cmxIYXNoO1xuICAgICAgfVxuXG4gICAgICAvLyBoaWRlIGNvbnRyb2xzXG4gICAgICBpZiAoIXNlbGYub3B0aW9ucy5zaG93Q29udHJvbHMpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXJPcHRpb25zLmNvbnRyb2xzID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gZW5hYmxlIGJhY2tncm91bmQgb3B0aW9uXG4gICAgICBpZiAoIXNlbGYub3B0aW9ucy5zaG93Q29udHJvbHMgJiYgc2VsZi5vcHRpb25zLmxvb3AgJiYgc2VsZi5vcHRpb25zLmF1dG9wbGF5KSB7XG4gICAgICAgIHNlbGYucGxheWVyT3B0aW9ucy5iYWNrZ3JvdW5kID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICghc2VsZi4kdmlkZW8pIHtcbiAgICAgICAgbGV0IHBsYXllck9wdGlvbnNTdHJpbmcgPSAnJztcbiAgICAgICAgT2JqZWN0LmtleXMoc2VsZi5wbGF5ZXJPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKHBsYXllck9wdGlvbnNTdHJpbmcgIT09ICcnKSB7XG4gICAgICAgICAgICBwbGF5ZXJPcHRpb25zU3RyaW5nICs9ICcmJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGxheWVyT3B0aW9uc1N0cmluZyArPSBgJHtrZXl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHNlbGYucGxheWVyT3B0aW9uc1trZXldKX1gO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBpZnJhbWUgbWFudWFsbHkgYmVjYXVzZSB3aGVuIHdlIGNyZWF0ZSBpdCB1c2luZyBBUElcbiAgICAgICAgLy8ganMgZXZlbnRzIHdvbid0IHRyaWdnZXJzIGFmdGVyIGlmcmFtZSBtb3ZlZCB0byBhbm90aGVyIHBsYWNlXG4gICAgICAgIHNlbGYuJHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnaWQnLCBzZWxmLnBsYXllcklEKTtcbiAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdzcmMnLCBgaHR0cHM6Ly9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLyR7c2VsZi52aWRlb0lEfT8ke3BsYXllck9wdGlvbnNTdHJpbmd9YCk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnZnJhbWVib3JkZXInLCAnMCcpO1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ21vemFsbG93ZnVsbHNjcmVlbicsICcnKTtcbiAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdhbGxvd2Z1bGxzY3JlZW4nLCAnJyk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnVmltZW8gdmlkZW8gcGxheWVyJyk7XG5cbiAgICAgICAgLy8gYWRkIGFjY2Vzc2liaWxpdHkgYXR0cmlidXRlc1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmFjY2Vzc2liaWxpdHlIaWRkZW4pIHtcbiAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZGVuRGl2LmFwcGVuZENoaWxkKHNlbGYuJHZpZGVvKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChoaWRkZW5EaXYpO1xuICAgICAgfVxuICAgICAgc2VsZi5wbGF5ZXIgPSBzZWxmLnBsYXllciB8fCBuZXcgZ2xvYmFsJDEuVmltZW8uUGxheWVyKHNlbGYuJHZpZGVvLCBzZWxmLnBsYXllck9wdGlvbnMpO1xuXG4gICAgICAvLyBTaW5jZSBWaW1lbyByZW1vdmVkIHRoZSBgdm9sdW1lYCBwYXJhbWV0ZXIsIHdlIGhhdmUgdG8gc2V0IGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKCFzZWxmLm9wdGlvbnMubXV0ZSAmJiB0eXBlb2Ygc2VsZi5vcHRpb25zLnZvbHVtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5zZXRWb2x1bWUoc2VsZi5vcHRpb25zLnZvbHVtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjdXJyZW50IHRpbWUgZm9yIGF1dG9wbGF5XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSAmJiBzZWxmLm9wdGlvbnMuYXV0b3BsYXkpIHtcbiAgICAgICAgc2VsZi5wbGF5ZXIuc2V0Q3VycmVudFRpbWUoc2VsZi5vcHRpb25zLnN0YXJ0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB2aWRlbyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBzZWxmLnBsYXllci5nZXRWaWRlb1dpZHRoKCkudGhlbih3aWR0aCA9PiB7XG4gICAgICAgIHNlbGYudmlkZW9XaWR0aCA9IHdpZHRoIHx8IDEyODA7XG4gICAgICB9KTtcbiAgICAgIHNlbGYucGxheWVyLmdldFZpZGVvSGVpZ2h0KCkudGhlbihoZWlnaHQgPT4ge1xuICAgICAgICBzZWxmLnZpZGVvSGVpZ2h0ID0gaGVpZ2h0IHx8IDcyMDtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBldmVudHNcbiAgICAgIGxldCB2bVN0YXJ0ZWQ7XG4gICAgICBzZWxmLnBsYXllci5vbigndGltZXVwZGF0ZScsIGUgPT4ge1xuICAgICAgICBpZiAoIXZtU3RhcnRlZCkge1xuICAgICAgICAgIHNlbGYuZmlyZSgnc3RhcnRlZCcsIGUpO1xuICAgICAgICAgIHZtU3RhcnRlZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5maXJlKCd0aW1ldXBkYXRlJywgZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGVuZCBvZiB2aWRlbyBhbmQgcGxheSBhZ2FpbiBvciBzdG9wXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSAmJiBlLnNlY29uZHMgPj0gc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgICAgIHNlbGYucGxheShzZWxmLm9wdGlvbnMuc3RhcnRUaW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5wYXVzZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbigncGxheScsIGUgPT4ge1xuICAgICAgICBzZWxmLmZpcmUoJ3BsYXknLCBlKTtcblxuICAgICAgICAvLyBjaGVjayBmb3IgdGhlIHN0YXJ0IHRpbWUgYW5kIHN0YXJ0IHdpdGggaXRcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5zdGFydFRpbWUgJiYgZS5zZWNvbmRzID09PSAwKSB7XG4gICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGYucGxheWVyLm9uKCdwYXVzZScsIGUgPT4ge1xuICAgICAgICBzZWxmLmZpcmUoJ3BhdXNlJywgZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYucGxheWVyLm9uKCdlbmRlZCcsIGUgPT4ge1xuICAgICAgICBzZWxmLmZpcmUoJ2VuZGVkJywgZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYucGxheWVyLm9uKCdsb2FkZWQnLCBlID0+IHtcbiAgICAgICAgc2VsZi5maXJlKCdyZWFkeScsIGUpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnBsYXllci5vbigndm9sdW1lY2hhbmdlJywgZSA9PiB7XG4gICAgICAgIHNlbGYuZ2V0Vm9sdW1lKHZvbHVtZSA9PiB7XG4gICAgICAgICAgc2VsZi5vcHRpb25zLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYuZmlyZSgndm9sdW1lY2hhbmdlJywgZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYucGxheWVyLm9uKCdlcnJvcicsIGUgPT4ge1xuICAgICAgICBzZWxmLmZpcmUoJ2Vycm9yJywgZSk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgVmlkZW9Xb3JrZXJMb2NhbCBleHRlbmRzIFZpZGVvV29ya2VyQmFzZSB7XG4gIHR5cGUgPSAnbG9jYWwnO1xuICBzdGF0aWMgcGFyc2VVUkwodXJsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgY29uc3QgdmlkZW9Gb3JtYXRzID0gdXJsLnNwbGl0KC8sKD89bXA0XFw6fHdlYm1cXDp8b2d2XFw6fG9nZ1xcOikvKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBsZXQgcmVhZHkgPSAwO1xuICAgIHZpZGVvRm9ybWF0cy5mb3JFYWNoKHZhbCA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAgIGNvbnN0IG1hdGNoID0gdmFsLm1hdGNoKC9eKG1wNHx3ZWJtfG9ndnxvZ2cpXFw6KC4qKS8pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdICYmIG1hdGNoWzJdKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICByZXN1bHRbbWF0Y2hbMV0gPT09ICdvZ3YnID8gJ29nZycgOiBtYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgICAgICAgcmVhZHkgPSAxO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZWFkeSA/IHJlc3VsdCA6IGZhbHNlO1xuICB9XG4gIHBsYXkoc3RhcnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RhcnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzZWxmLnBsYXllci5jdXJyZW50VGltZSA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoc2VsZi5wbGF5ZXIucGF1c2VkKSB7XG4gICAgICAvLyBEb24ndCBwbGF5IGlmIHZpZGVvIGlzIGFscmVhZHkgZW5kZWQgYW5kIHdpdGggbm8gbG9vcC5cbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuZW5kVGltZSAmJiAhc2VsZi5vcHRpb25zLmxvb3ApIHtcbiAgICAgICAgc2VsZi5nZXRDdXJyZW50VGltZShzZWNvbmRzID0+IHtcbiAgICAgICAgICBpZiAoc2Vjb25kcyA8IHNlbGYub3B0aW9ucy5lbmRUaW1lKSB7XG4gICAgICAgICAgICBzZWxmLnBsYXllci5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucGxheWVyLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCBzZWxmLnBsYXllci5wYXVzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5wbGF5ZXIucGF1c2UoKTtcbiAgfVxuICBtdXRlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmICghc2VsZi5wbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi4kdmlkZW8ubXV0ZWQgPSB0cnVlO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuJHZpZGVvLm11dGVkID0gZmFsc2U7XG4gIH1cbiAgc2V0Vm9sdW1lKHZvbHVtZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCB0eXBlb2Ygdm9sdW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLiR2aWRlby52b2x1bWUgPSB2b2x1bWUgLyAxMDA7XG4gIH1cbiAgZ2V0Vm9sdW1lKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhzZWxmLiR2aWRlby52b2x1bWUgKiAxMDApO1xuICB9XG4gIGdldE11dGVkKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllcikge1xuICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvLm11dGVkKTtcbiAgfVxuICBzZXRDdXJyZW50VGltZShjdXJyZW50VGltZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFzZWxmLnBsYXllciB8fCB0eXBlb2YgY3VycmVudFRpbWUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuJHZpZGVvLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cbiAgZ2V0Q3VycmVudFRpbWUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoIXNlbGYucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKHNlbGYucGxheWVyLmN1cnJlbnRUaW1lKTtcbiAgfVxuICBnZXRJbWFnZVVSTChjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGlmIChzZWxmLnZpZGVvSW1hZ2UpIHtcbiAgICAgIGNhbGxiYWNrKHNlbGYudmlkZW9JbWFnZSk7XG4gICAgfVxuICB9XG4gIGdldFZpZGVvKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyByZXR1cm4gZ2VuZXJhdGVkIHZpZGVvIGJsb2NrXG4gICAgaWYgKHNlbGYuJHZpZGVvKSB7XG4gICAgICBjYWxsYmFjayhzZWxmLiR2aWRlbyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2VuZXJhdGUgbmV3IHZpZGVvIGJsb2NrXG4gICAgbGV0IGhpZGRlbkRpdjtcbiAgICBpZiAoIXNlbGYuJHZpZGVvKSB7XG4gICAgICBoaWRkZW5EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGhpZGRlbkRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRTb3VyY2VFbGVtZW50KGVsZW1lbnQsIHNyYywgdHlwZSkge1xuICAgICAgY29uc3Qgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gICAgICBzb3VyY2Uuc3JjID0gc3JjO1xuICAgICAgc291cmNlLnR5cGUgPSB0eXBlO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXNlbGYuJHZpZGVvKSB7XG4gICAgICBzZWxmLiR2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICBzZWxmLnBsYXllciA9IHNlbGYuJHZpZGVvO1xuXG4gICAgICAvLyBzaG93IGNvbnRyb2xzXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLnNob3dDb250cm9scykge1xuICAgICAgICBzZWxmLiR2aWRlby5jb250cm9scyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB2b2x1bWVcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLnZvbHVtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2VsZi5zZXRWb2x1bWUoc2VsZi5vcHRpb25zLnZvbHVtZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG11dGUgKGl0IGlzIHJlcXVpcmVkIHRvIG11dGUgYWZ0ZXIgdGhlIHZvbHVtZSBzZXQpXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLm11dGUpIHtcbiAgICAgICAgc2VsZi5tdXRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvb3BcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMubG9vcCkge1xuICAgICAgICBzZWxmLiR2aWRlby5sb29wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXV0b3BsYXkgZW5hYmxlIG9uIG1vYmlsZSBkZXZpY2VzXG4gICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJycpO1xuICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnJyk7XG5cbiAgICAgIC8vIGFkZCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXNcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuYWNjZXNzaWJpbGl0eUhpZGRlbikge1xuICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgfVxuICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdpZCcsIHNlbGYucGxheWVySUQpO1xuICAgICAgaGlkZGVuRGl2LmFwcGVuZENoaWxkKHNlbGYuJHZpZGVvKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGlkZGVuRGl2KTtcbiAgICAgIE9iamVjdC5rZXlzKHNlbGYudmlkZW9JRCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBhZGRTb3VyY2VFbGVtZW50KHNlbGYuJHZpZGVvLCBzZWxmLnZpZGVvSURba2V5XSwgYHZpZGVvLyR7a2V5fWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBsb2NTdGFydGVkO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBlID0+IHtcbiAgICAgIGlmICghbG9jU3RhcnRlZCkge1xuICAgICAgICBzZWxmLmZpcmUoJ3N0YXJ0ZWQnLCBlKTtcbiAgICAgIH1cbiAgICAgIGxvY1N0YXJ0ZWQgPSAxO1xuICAgIH0pO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgc2VsZi5maXJlKCd0aW1ldXBkYXRlJywgZSk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBlbmQgb2YgdmlkZW8gYW5kIHBsYXkgYWdhaW4gb3Igc3RvcFxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmRUaW1lICYmIHRoaXMuY3VycmVudFRpbWUgPj0gc2VsZi5vcHRpb25zLmVuZFRpbWUpIHtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5sb29wKSB7XG4gICAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCBlID0+IHtcbiAgICAgIHNlbGYuZmlyZSgncGxheScsIGUpO1xuICAgIH0pO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgZSA9PiB7XG4gICAgICBzZWxmLmZpcmUoJ3BhdXNlJywgZSk7XG4gICAgfSk7XG4gICAgc2VsZi5wbGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBlID0+IHtcbiAgICAgIHNlbGYuZmlyZSgnZW5kZWQnLCBlKTtcbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGdldCB2aWRlbyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBzZWxmLnZpZGVvV2lkdGggPSB0aGlzLnZpZGVvV2lkdGggfHwgMTI4MDtcbiAgICAgIHNlbGYudmlkZW9IZWlnaHQgPSB0aGlzLnZpZGVvSGVpZ2h0IHx8IDcyMDtcbiAgICAgIHNlbGYuZmlyZSgncmVhZHknKTtcblxuICAgICAgLy8gYXV0b3BsYXlcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuYXV0b3BsYXkpIHtcbiAgICAgICAgc2VsZi5wbGF5KHNlbGYub3B0aW9ucy5zdGFydFRpbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYucGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ3ZvbHVtZWNoYW5nZScsIGUgPT4ge1xuICAgICAgc2VsZi5nZXRWb2x1bWUodm9sdW1lID0+IHtcbiAgICAgICAgc2VsZi5vcHRpb25zLnZvbHVtZSA9IHZvbHVtZTtcbiAgICAgIH0pO1xuICAgICAgc2VsZi5maXJlKCd2b2x1bWVjaGFuZ2UnLCBlKTtcbiAgICB9KTtcbiAgICBzZWxmLnBsYXllci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGUgPT4ge1xuICAgICAgc2VsZi5maXJlKCdlcnJvcicsIGUpO1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKHNlbGYuJHZpZGVvKTtcbiAgfVxufVxuZnVuY3Rpb24gVmlkZW9Xb3JrZXIodXJsLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgT2JqZWN0LmtleXMoVmlkZW9Xb3JrZXIucHJvdmlkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKCFyZXN1bHQgJiYgVmlkZW9Xb3JrZXIucHJvdmlkZXJzW2tleV0ucGFyc2VVUkwodXJsKSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFZpZGVvV29ya2VyLnByb3ZpZGVyc1trZXldKHVybCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdCB8fCBuZXcgVmlkZW9Xb3JrZXJCYXNlKHVybCwgb3B0aW9ucyk7XG59XG5WaWRlb1dvcmtlci5CYXNlQ2xhc3MgPSBWaWRlb1dvcmtlckJhc2U7XG5WaWRlb1dvcmtlci5wcm92aWRlcnMgPSB7XG4gIFlvdXR1YmU6IFZpZGVvV29ya2VyWW91dHViZSxcbiAgVmltZW86IFZpZGVvV29ya2VyVmltZW8sXG4gIExvY2FsOiBWaWRlb1dvcmtlckxvY2FsXG59O1xuXG5mdW5jdGlvbiBqYXJhbGxheFZpZGVvJDEoamFyYWxsYXggPSBnbG9iYWwkMi5qYXJhbGxheCkge1xuICBpZiAodHlwZW9mIGphcmFsbGF4ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBKYXJhbGxheCA9IGphcmFsbGF4LmNvbnN0cnVjdG9yO1xuXG4gIC8vIGFwcGVuZCB2aWRlbyBhZnRlciB3aGVuIGJsb2NrIHdpbGwgYmUgdmlzaWJsZS5cbiAgY29uc3QgZGVmT25TY3JvbGwgPSBKYXJhbGxheC5wcm90b3R5cGUub25TY3JvbGw7XG4gIEphcmFsbGF4LnByb3RvdHlwZS5vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBkZWZPblNjcm9sbC5hcHBseShzZWxmKTtcbiAgICBjb25zdCBpc1JlYWR5ID0gIXNlbGYuaXNWaWRlb0luc2VydGVkICYmIHNlbGYudmlkZW8gJiYgKCFzZWxmLm9wdGlvbnMudmlkZW9MYXp5TG9hZGluZyB8fCBzZWxmLmlzRWxlbWVudEluVmlld3BvcnQpICYmICFzZWxmLm9wdGlvbnMuZGlzYWJsZVZpZGVvKCk7XG4gICAgaWYgKGlzUmVhZHkpIHtcbiAgICAgIHNlbGYuaXNWaWRlb0luc2VydGVkID0gdHJ1ZTtcbiAgICAgIHNlbGYudmlkZW8uZ2V0VmlkZW8odmlkZW8gPT4ge1xuICAgICAgICBjb25zdCAkcGFyZW50ID0gdmlkZW8ucGFyZW50Tm9kZTtcbiAgICAgICAgc2VsZi5jc3ModmlkZW8sIHtcbiAgICAgICAgICBwb3NpdGlvbjogc2VsZi5pbWFnZS5wb3NpdGlvbixcbiAgICAgICAgICB0b3A6ICcwcHgnLFxuICAgICAgICAgIGxlZnQ6ICcwcHgnLFxuICAgICAgICAgIHJpZ2h0OiAnMHB4JyxcbiAgICAgICAgICBib3R0b206ICcwcHgnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgbWF4V2lkdGg6ICdub25lJyxcbiAgICAgICAgICBtYXhIZWlnaHQ6ICdub25lJyxcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICAgICAgdHJhbnNmb3JtU3R5bGU6ICdwcmVzZXJ2ZS0zZCcsXG4gICAgICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgekluZGV4OiAtMVxuICAgICAgICB9KTtcbiAgICAgICAgc2VsZi4kdmlkZW8gPSB2aWRlbztcblxuICAgICAgICAvLyBhZGQgUG9zdGVyIGF0dHJpYnV0ZSB0byBzZWxmLWhvc3RlZCB2aWRlb1xuICAgICAgICBpZiAoc2VsZi52aWRlby50eXBlID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgaWYgKHNlbGYuaW1hZ2Uuc3JjKSB7XG4gICAgICAgICAgICBzZWxmLiR2aWRlby5zZXRBdHRyaWJ1dGUoJ3Bvc3RlcicsIHNlbGYuaW1hZ2Uuc3JjKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW1hZ2UuJGl0ZW0gJiYgc2VsZi5pbWFnZS4kaXRlbS50YWdOYW1lID09PSAnSU1HJyAmJiBzZWxmLmltYWdlLiRpdGVtLnNyYykge1xuICAgICAgICAgICAgc2VsZi4kdmlkZW8uc2V0QXR0cmlidXRlKCdwb3N0ZXInLCBzZWxmLmltYWdlLiRpdGVtLnNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIGNsYXNzbmFtZSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMudmlkZW9DbGFzcykge1xuICAgICAgICAgIHNlbGYuJHZpZGVvLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBgJHtzZWxmLm9wdGlvbnMudmlkZW9DbGFzc30gJHtzZWxmLm9wdGlvbnMudmlkZW9DbGFzc30tJHtzZWxmLnZpZGVvLnR5cGV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnNlcnQgdmlkZW8gdGFnXG4gICAgICAgIHNlbGYuaW1hZ2UuJGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWRlbyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHBhcmVudCB2aWRlbyBlbGVtZW50IChjcmVhdGVkIGJ5IFZpZGVvV29ya2VyKVxuICAgICAgICAkcGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoJHBhcmVudCk7XG5cbiAgICAgICAgLy8gY2FsbCBvblZpZGVvSW5zZXJ0IGV2ZW50XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMub25WaWRlb0luc2VydCkge1xuICAgICAgICAgIHNlbGYub3B0aW9ucy5vblZpZGVvSW5zZXJ0LmNhbGwoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBjb3ZlciB2aWRlb1xuICBjb25zdCBkZWZDb3ZlckltYWdlID0gSmFyYWxsYXgucHJvdG90eXBlLmNvdmVySW1hZ2U7XG4gIEphcmFsbGF4LnByb3RvdHlwZS5jb3ZlckltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGRlZkNvdmVySW1hZ2UuYXBwbHkoc2VsZik7XG4gICAgY29uc3Qgbm9kZSA9IHNlbGYuaW1hZ2UuJGl0ZW0gPyBzZWxmLmltYWdlLiRpdGVtLm5vZGVOYW1lIDogZmFsc2U7XG4gICAgaWYgKGltYWdlRGF0YSAmJiBzZWxmLnZpZGVvICYmIG5vZGUgJiYgKG5vZGUgPT09ICdJRlJBTUUnIHx8IG5vZGUgPT09ICdWSURFTycpKSB7XG4gICAgICBsZXQgaCA9IGltYWdlRGF0YS5pbWFnZS5oZWlnaHQ7XG4gICAgICBsZXQgdyA9IGggKiBzZWxmLmltYWdlLndpZHRoIC8gc2VsZi5pbWFnZS5oZWlnaHQ7XG4gICAgICBsZXQgbWwgPSAoaW1hZ2VEYXRhLmNvbnRhaW5lci53aWR0aCAtIHcpIC8gMjtcbiAgICAgIGxldCBtdCA9IGltYWdlRGF0YS5pbWFnZS5tYXJnaW5Ub3A7XG4gICAgICBpZiAoaW1hZ2VEYXRhLmNvbnRhaW5lci53aWR0aCA+IHcpIHtcbiAgICAgICAgdyA9IGltYWdlRGF0YS5jb250YWluZXIud2lkdGg7XG4gICAgICAgIGggPSB3ICogc2VsZi5pbWFnZS5oZWlnaHQgLyBzZWxmLmltYWdlLndpZHRoO1xuICAgICAgICBtbCA9IDA7XG4gICAgICAgIG10ICs9IChpbWFnZURhdGEuaW1hZ2UuaGVpZ2h0IC0gaCkgLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdmlkZW8gaGVpZ2h0IG92ZXIgdGhhbiBuZWVkIHRvIGhpZGUgY29udHJvbHNcbiAgICAgIGlmIChub2RlID09PSAnSUZSQU1FJykge1xuICAgICAgICBoICs9IDQwMDtcbiAgICAgICAgbXQgLT0gMjAwO1xuICAgICAgfVxuICAgICAgc2VsZi5jc3Moc2VsZi4kdmlkZW8sIHtcbiAgICAgICAgd2lkdGg6IGAke3d9cHhgLFxuICAgICAgICBtYXJnaW5MZWZ0OiBgJHttbH1weGAsXG4gICAgICAgIGhlaWdodDogYCR7aH1weGAsXG4gICAgICAgIG1hcmdpblRvcDogYCR7bXR9cHhgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgfTtcblxuICAvLyBpbml0IHZpZGVvXG4gIGNvbnN0IGRlZkluaXRJbWcgPSBKYXJhbGxheC5wcm90b3R5cGUuaW5pdEltZztcbiAgSmFyYWxsYXgucHJvdG90eXBlLmluaXRJbWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgZGVmYXVsdFJlc3VsdCA9IGRlZkluaXRJbWcuYXBwbHkoc2VsZik7XG4gICAgaWYgKCFzZWxmLm9wdGlvbnMudmlkZW9TcmMpIHtcbiAgICAgIHNlbGYub3B0aW9ucy52aWRlb1NyYyA9IHNlbGYuJGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWphcmFsbGF4LXZpZGVvJykgfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKHNlbGYub3B0aW9ucy52aWRlb1NyYykge1xuICAgICAgc2VsZi5kZWZhdWx0SW5pdEltZ1Jlc3VsdCA9IGRlZmF1bHRSZXN1bHQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XG4gIH07XG4gIGNvbnN0IGRlZkNhbkluaXRQYXJhbGxheCA9IEphcmFsbGF4LnByb3RvdHlwZS5jYW5Jbml0UGFyYWxsYXg7XG4gIEphcmFsbGF4LnByb3RvdHlwZS5jYW5Jbml0UGFyYWxsYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlZmF1bHRSZXN1bHQgPSBkZWZDYW5Jbml0UGFyYWxsYXguYXBwbHkoc2VsZik7XG4gICAgaWYgKCFzZWxmLm9wdGlvbnMudmlkZW9TcmMpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xuICAgIH1cblxuICAgIC8vIEluaXQgdmlkZW8gYXBpXG4gICAgY29uc3QgdmlkZW8gPSBuZXcgVmlkZW9Xb3JrZXIoc2VsZi5vcHRpb25zLnZpZGVvU3JjLCB7XG4gICAgICBhdXRvcGxheTogdHJ1ZSxcbiAgICAgIGxvb3A6IHNlbGYub3B0aW9ucy52aWRlb0xvb3AsXG4gICAgICBzaG93Q29udHJvbHM6IGZhbHNlLFxuICAgICAgYWNjZXNzaWJpbGl0eUhpZGRlbjogdHJ1ZSxcbiAgICAgIHN0YXJ0VGltZTogc2VsZi5vcHRpb25zLnZpZGVvU3RhcnRUaW1lIHx8IDAsXG4gICAgICBlbmRUaW1lOiBzZWxmLm9wdGlvbnMudmlkZW9FbmRUaW1lIHx8IDAsXG4gICAgICBtdXRlOiAhc2VsZi5vcHRpb25zLnZpZGVvVm9sdW1lLFxuICAgICAgdm9sdW1lOiBzZWxmLm9wdGlvbnMudmlkZW9Wb2x1bWUgfHwgMFxuICAgIH0pO1xuXG4gICAgLy8gY2FsbCBvblZpZGVvV29ya2VySW5pdCBldmVudFxuICAgIGlmIChzZWxmLm9wdGlvbnMub25WaWRlb1dvcmtlckluaXQpIHtcbiAgICAgIHNlbGYub3B0aW9ucy5vblZpZGVvV29ya2VySW5pdC5jYWxsKHNlbGYsIHZpZGVvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXREZWZhdWx0SW1hZ2UoKSB7XG4gICAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0gPSBzZWxmLmltYWdlLiRkZWZhdWx0X2l0ZW07XG4gICAgICAgIHNlbGYuaW1hZ2UuJGl0ZW0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgLy8gc2V0IGltYWdlIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgICAgc2VsZi5jb3ZlckltYWdlKCk7XG4gICAgICAgIHNlbGYub25TY3JvbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZpZGVvLmlzVmFsaWQoKSkge1xuICAgICAgLy8gRm9yY2UgZW5hYmxlIHBhcmFsbGF4LlxuICAgICAgLy8gV2hlbiB0aGUgcGFyYWxsYXggZGlzYWJsZWQgb24gbW9iaWxlIGRldmljZXMsIHdlIHN0aWxsIG5lZWQgdG8gZGlzcGxheSB2aWRlb3MuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmstby9qYXJhbGxheC9pc3N1ZXMvMTU5XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVQYXJhbGxheCgpKSB7XG4gICAgICAgIGRlZmF1bHRSZXN1bHQgPSB0cnVlO1xuICAgICAgICBzZWxmLmltYWdlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgc2VsZi5vcHRpb25zLnR5cGUgPSAnc2Nyb2xsJztcbiAgICAgICAgc2VsZi5vcHRpb25zLnNwZWVkID0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgcGFyYWxsYXggd2lsbCBub3QgYmUgaW5pdGVkLCB3ZSBjYW4gYWRkIHRodW1ibmFpbCBvbiBiYWNrZ3JvdW5kLlxuICAgICAgaWYgKCFkZWZhdWx0UmVzdWx0KSB7XG4gICAgICAgIGlmICghc2VsZi5kZWZhdWx0SW5pdEltZ1Jlc3VsdCkge1xuICAgICAgICAgIHZpZGVvLmdldEltYWdlVVJMKHVybCA9PiB7XG4gICAgICAgICAgICAvLyBzYXZlIGRlZmF1bHQgdXNlciBzdHlsZXNcbiAgICAgICAgICAgIGNvbnN0IGN1clN0eWxlID0gc2VsZi4kaXRlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICBpZiAoY3VyU3R5bGUpIHtcbiAgICAgICAgICAgICAgc2VsZi4kaXRlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtamFyYWxsYXgtb3JpZ2luYWwtc3R5bGVzJywgY3VyU3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgbmV3IGJhY2tncm91bmRcbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiBgdXJsKFwiJHt1cmx9XCIpYCxcbiAgICAgICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24nOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgJ2JhY2tncm91bmQtc2l6ZSc6ICdjb3ZlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5pdCB2aWRlb1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlkZW8ub24oJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMudmlkZW9QbGF5T25seVZpc2libGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZE9uU2Nyb2xsID0gc2VsZi5vblNjcm9sbDtcbiAgICAgICAgICAgIHNlbGYub25TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIG9sZE9uU2Nyb2xsLmFwcGx5KHNlbGYpO1xuICAgICAgICAgICAgICBpZiAoIXNlbGYudmlkZW9FcnJvciAmJiAoc2VsZi5vcHRpb25zLnZpZGVvTG9vcCB8fCAhc2VsZi5vcHRpb25zLnZpZGVvTG9vcCAmJiAhc2VsZi52aWRlb0VuZGVkKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZpZGVvLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmlkZW8ub24oJ3N0YXJ0ZWQnLCAoKSA9PiB7XG4gICAgICAgICAgc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtID0gc2VsZi5pbWFnZS4kaXRlbTtcbiAgICAgICAgICBzZWxmLmltYWdlLiRpdGVtID0gc2VsZi4kdmlkZW87XG5cbiAgICAgICAgICAvLyBzZXQgdmlkZW8gd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgIHNlbGYuaW1hZ2Uud2lkdGggPSBzZWxmLnZpZGVvLnZpZGVvV2lkdGggfHwgMTI4MDtcbiAgICAgICAgICBzZWxmLmltYWdlLmhlaWdodCA9IHNlbGYudmlkZW8udmlkZW9IZWlnaHQgfHwgNzIwO1xuICAgICAgICAgIHNlbGYuY292ZXJJbWFnZSgpO1xuICAgICAgICAgIHNlbGYub25TY3JvbGwoKTtcblxuICAgICAgICAgIC8vIGhpZGUgaW1hZ2VcbiAgICAgICAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICAgICAgICBzZWxmLmltYWdlLiRkZWZhdWx0X2l0ZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWRlby5vbignZW5kZWQnLCAoKSA9PiB7XG4gICAgICAgICAgc2VsZi52aWRlb0VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXNlbGYub3B0aW9ucy52aWRlb0xvb3ApIHtcbiAgICAgICAgICAgIC8vIHNob3cgZGVmYXVsdCBpbWFnZSBpZiBMb29wIGRpc2FibGVkLlxuICAgICAgICAgICAgcmVzZXREZWZhdWx0SW1hZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2aWRlby5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgc2VsZi52aWRlb0Vycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHNob3cgZGVmYXVsdCBpbWFnZSBpZiB2aWRlbyBsb2FkaW5nIGVycm9yLlxuICAgICAgICAgIHJlc2V0RGVmYXVsdEltYWdlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnZpZGVvID0gdmlkZW87XG5cbiAgICAgICAgLy8gc2V0IGltYWdlIGlmIG5vdCBleGlzdHNcbiAgICAgICAgaWYgKCFzZWxmLmRlZmF1bHRJbml0SW1nUmVzdWx0KSB7XG4gICAgICAgICAgLy8gc2V0IGVtcHR5IGltYWdlIG9uIHNlbGYtaG9zdGVkIHZpZGVvIGlmIG5vdCBkZWZpbmVkXG4gICAgICAgICAgc2VsZi5pbWFnZS5zcmMgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JztcbiAgICAgICAgICBpZiAodmlkZW8udHlwZSAhPT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgdmlkZW8uZ2V0SW1hZ2VVUkwodXJsID0+IHtcbiAgICAgICAgICAgICAgc2VsZi5pbWFnZS5iZ0ltYWdlID0gYHVybChcIiR7dXJsfVwiKWA7XG4gICAgICAgICAgICAgIHNlbGYuaW5pdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xuICB9O1xuXG4gIC8vIERlc3Ryb3kgdmlkZW8gcGFyYWxsYXhcbiAgY29uc3QgZGVmRGVzdHJveSA9IEphcmFsbGF4LnByb3RvdHlwZS5kZXN0cm95O1xuICBKYXJhbGxheC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtKSB7XG4gICAgICBzZWxmLmltYWdlLiRpdGVtID0gc2VsZi5pbWFnZS4kZGVmYXVsdF9pdGVtO1xuICAgICAgZGVsZXRlIHNlbGYuaW1hZ2UuJGRlZmF1bHRfaXRlbTtcbiAgICB9XG4gICAgZGVmRGVzdHJveS5hcHBseShzZWxmKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gamFyYWxsYXhFbGVtZW50JDEoamFyYWxsYXggPSBnbG9iYWwkMi5qYXJhbGxheCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLndhcm4oXCJKYXJhbGxheCBFbGVtZW50IGV4dGVuc2lvbiBpcyBERVBSRUNBVEVELCBwbGVhc2UsIGF2b2lkIHVzaW5nIGl0LiBXZSByZWNvbW1lbmQgeW91IGxvb2sgYXQgc29tZXRoaW5nIGxpa2UgYGxheC5qc2AgbGlicmFyeSA8aHR0cHM6Ly9naXRodWIuY29tL2FsZXhmb3h5L2xheC5qcz4uIEl0IGlzIG11Y2ggbW9yZSBwb3dlcmZ1bCBhbmQgaGFzIGEgbGVzcyBjb2RlIChpbiBjYXNlcyB3aGVuIHlvdSBkb24ndCB3YW50IHRvIGFkZCBwYXJhbGxheCBiYWNrZ3JvdW5kcykuXCIpO1xuICBpZiAodHlwZW9mIGphcmFsbGF4ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBKYXJhbGxheCA9IGphcmFsbGF4LmNvbnN0cnVjdG9yO1xuXG4gIC8vIHJlZGVmaW5lIGRlZmF1bHQgbWV0aG9kc1xuICBbJ2luaXRJbWcnLCAnY2FuSW5pdFBhcmFsbGF4JywgJ2luaXQnLCAnZGVzdHJveScsICdjb3ZlckltYWdlJywgJ2lzVmlzaWJsZScsICdvblNjcm9sbCcsICdvblJlc2l6ZSddLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBkZWYgPSBKYXJhbGxheC5wcm90b3R5cGVba2V5XTtcbiAgICBKYXJhbGxheC5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgIGlmIChrZXkgPT09ICdpbml0SW1nJyAmJiBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1lbGVtZW50JykgIT09IG51bGwpIHtcbiAgICAgICAgc2VsZi5vcHRpb25zLnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICAgIHNlbGYucHVyZU9wdGlvbnMuc3BlZWQgPSBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1lbGVtZW50JykgfHwgJzEwMCc7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5vcHRpb25zLnR5cGUgIT09ICdlbGVtZW50Jykge1xuICAgICAgICByZXR1cm4gZGVmLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgc2VsZi5wdXJlT3B0aW9ucy50aHJlc2hvbGQgPSBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS10aHJlc2hvbGQnKSB8fCAnJztcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkQXJyID0gYCR7c2VsZi5wdXJlT3B0aW9ucy5zcGVlZH1gLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuc3BlZWQgPSBzZWxmLnB1cmVPcHRpb25zLnNwZWVkIHx8IDA7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuc3BlZWRZID0gc3BlZWRBcnJbMF0gPyBwYXJzZUZsb2F0KHNwZWVkQXJyWzBdKSA6IDA7XG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMuc3BlZWRYID0gc3BlZWRBcnJbMV0gPyBwYXJzZUZsb2F0KHNwZWVkQXJyWzFdKSA6IDA7XG4gICAgICAgICAgICBjb25zdCB0aHJlc2hvbGRBcnIgPSBzZWxmLnB1cmVPcHRpb25zLnRocmVzaG9sZC5zcGxpdCgnICcpO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRocmVzaG9sZFkgPSB0aHJlc2hvbGRBcnJbMF0gPyBwYXJzZUZsb2F0KHRocmVzaG9sZEFyclswXSkgOiBudWxsO1xuICAgICAgICAgICAgc2VsZi5vcHRpb25zLnRocmVzaG9sZFggPSB0aHJlc2hvbGRBcnJbMV0gPyBwYXJzZUZsb2F0KHRocmVzaG9sZEFyclsxXSkgOiBudWxsO1xuICAgICAgICAgICAgZGVmLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgICAvLyByZXN0b3JlIGJhY2tncm91bmQgaW1hZ2UgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdHlsZXNUYWcgPSBzZWxmLiRpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1qYXJhbGxheC1vcmlnaW5hbC1zdHlsZXMnKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0eWxlc1RhZykge1xuICAgICAgICAgICAgICBzZWxmLiRpdGVtLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBvcmlnaW5hbFN0eWxlc1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ29uUmVzaXplJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBkZWZUcmFuc2Zvcm0gPSBzZWxmLmNzcyhzZWxmLiRpdGVtLCAndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHNlbGYuJGl0ZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBzZWxmLml0ZW1EYXRhID0ge1xuICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgICAgeTogcmVjdC50b3AgKyBzZWxmLmdldFdpbmRvd0RhdGEoKS55LFxuICAgICAgICAgICAgICB4OiByZWN0LmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmNzcyhzZWxmLiRpdGVtLCB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogZGVmVHJhbnNmb3JtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnb25TY3JvbGwnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHduZCA9IHNlbGYuZ2V0V2luZG93RGF0YSgpO1xuICAgICAgICAgICAgY29uc3QgY2VudGVyUGVyY2VudCA9ICh3bmQueSArIHduZC5oZWlnaHQgLyAyIC0gc2VsZi5pdGVtRGF0YS55IC0gc2VsZi5pdGVtRGF0YS5oZWlnaHQgLyAyKSAvICh3bmQuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICBjb25zdCBtb3ZlWSA9IGNlbnRlclBlcmNlbnQgKiBzZWxmLm9wdGlvbnMuc3BlZWRZO1xuICAgICAgICAgICAgY29uc3QgbW92ZVggPSBjZW50ZXJQZXJjZW50ICogc2VsZi5vcHRpb25zLnNwZWVkWDtcbiAgICAgICAgICAgIGxldCBteSA9IG1vdmVZO1xuICAgICAgICAgICAgbGV0IG14ID0gbW92ZVg7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLnRocmVzaG9sZFkgIT09IG51bGwgJiYgbW92ZVkgPiBzZWxmLm9wdGlvbnMudGhyZXNob2xkWSkgbXkgPSAwO1xuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy50aHJlc2hvbGRYICE9PSBudWxsICYmIG1vdmVYID4gc2VsZi5vcHRpb25zLnRocmVzaG9sZFgpIG14ID0gMDtcbiAgICAgICAgICAgIHNlbGYuY3NzKHNlbGYuJGl0ZW0sIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtteH1weCwke215fXB4LDApYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2luaXRJbWcnOlxuICAgICAgICBjYXNlICdpc1Zpc2libGUnOlxuICAgICAgICBjYXNlICdjb3ZlckltYWdlJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9O1xuICB9KTtcbn1cblxuY29uc3QgamFyYWxsYXggPSBqYXJhbGxheCQxO1xuY29uc3QgamFyYWxsYXhWaWRlbyA9IGZ1bmN0aW9uIGphcmFsbGF4VmlkZW8oKSB7XG4gIHJldHVybiBqYXJhbGxheFZpZGVvJDEoamFyYWxsYXgpO1xufTtcbmNvbnN0IGphcmFsbGF4RWxlbWVudCA9IGZ1bmN0aW9uIGphcmFsbGF4RWxlbWVudCgpIHtcbiAgcmV0dXJuIGphcmFsbGF4RWxlbWVudCQxKGphcmFsbGF4KTtcbn07XG5cbmV4cG9ydHMuamFyYWxsYXggPSBqYXJhbGxheDtcbmV4cG9ydHMuamFyYWxsYXhFbGVtZW50ID0gamFyYWxsYXhFbGVtZW50O1xuZXhwb3J0cy5qYXJhbGxheFZpZGVvID0gamFyYWxsYXhWaWRlbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWphcmFsbGF4LmNqcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jarallax/dist/jarallax.cjs\n");

/***/ })

};
;